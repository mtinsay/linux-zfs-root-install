#!/bin/bash

# ZFS Root Installation Scripts - Stage 3: Cleanup (v0.1)
# Copyright (C) 2025 Michael C. Tinsay
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Run this script after exiting chroot to clean up and prepare for reboot
#
# ⚠️  AI-GENERATED CODE DISCLAIMER ⚠️
# This script was entirely generated by AI without direct human editing.
# No comprehensive human testing or code review has been performed.
# Thoroughly test in isolated environments and have qualified personnel
# review before using in any production or important system.
# Use at your own risk - AI-generated code may contain subtle bugs.

# Enhanced bash options for better error handling
set -Euo pipefail

# Error handling with line number reporting
error_exit() {
    echo -e "${RED}ERROR: Script failed at line $1${NC}" >&2
    echo -e "${RED}Command: $2${NC}" >&2
    exit 1
}
trap 'error_exit ${LINENO} "$BASH_COMMAND"' ERR

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/ubuntu-config.sh"

if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Configuration file $CONFIG_FILE not found!"
    echo "Please ensure ubuntu-config.sh exists in the same directory as this script."
    exit 1
fi

source "$CONFIG_FILE"

# Colors are loaded from ubuntu-config.sh

validate_stage3_config() {
    local missing_vars=()
    
    # Required variables for stage3
    local required_vars=(
        "INSTALL_ROOT"
        "RED"
        "GREEN"
        "YELLOW"
        "NC"
    )
    
    # Check required variables
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var}" ]]; then
            missing_vars+=("$var")
        fi
    done
    
    # Report missing variables
    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        echo -e "${RED}[ERROR] Missing required configuration variables in ubuntu-config.sh:${NC}"
        for var in "${missing_vars[@]}"; do
            echo -e "${RED}[ERROR]   - $var${NC}"
        done
        echo -e "${RED}[ERROR]${NC}"
        echo -e "${RED}[ERROR] Please check your ubuntu-config.sh file and ensure all required variables are defined.${NC}"
        exit 1
    fi
}

log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

debug_break() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        warn "DEBUG BREAK: $1"
        warn "Exiting with error status for debugging..."
        exit 99  # Special debug exit code
    fi
}

aggressive_cleanup() {
    log "Preparing for unmount by killing interfering processes..."
    
    local processes_killed=false
    
    # Kill all processes with open files under $INSTALL_ROOT
    log "Killing processes with open files under $INSTALL_ROOT..."
    local open_file_pids=$(lsof +D "$INSTALL_ROOT" 2>/dev/null | awk 'NR>1 {print $2}' | grep '^[0-9]\+$' | sort -u || true)
    if [[ -n "$open_file_pids" ]]; then
        echo "$open_file_pids" | xargs -r kill -TERM 2>/dev/null || true
        sleep 2
        echo "$open_file_pids" | xargs -r kill -KILL 2>/dev/null || true
        log "Killed processes with open files under $INSTALL_ROOT"
        processes_killed=true
    else
        log "No processes with open files under $INSTALL_ROOT found"
    fi
    
    # Kill all processes with working directory under $INSTALL_ROOT
    log "Killing processes with working directory under $INSTALL_ROOT..."
    local cwd_pids=$(lsof +D "$INSTALL_ROOT" -a -d cwd 2>/dev/null | awk 'NR>1 {print $2}' | grep '^[0-9]\+$' | sort -u || true)
    if [[ -n "$cwd_pids" ]]; then
        echo "$cwd_pids" | xargs -r kill -TERM 2>/dev/null || true
        sleep 2
        echo "$cwd_pids" | xargs -r kill -KILL 2>/dev/null || true
        log "Killed processes with working directory under $INSTALL_ROOT"
        processes_killed=true
    else
        log "No processes with working directory under $INSTALL_ROOT found"
    fi
    
    # Disable all swap
    log "Disabling all swap..."
    swapoff -a 2>/dev/null || true
    log "All swap disabled"
    
    # Kill processes using the root pool
    log "Killing processes using root pool $POOL_NAME..."
    local root_pool_pids=$(grep "$POOL_NAME" /proc/*/mounts 2>/dev/null | cut -d/ -f3 | grep '^[0-9]\+$' | sort -u || true)
    if [[ -n "$root_pool_pids" ]]; then
        echo "$root_pool_pids" | xargs -r kill -TERM 2>/dev/null || true; sleep 2; echo "$root_pool_pids" | xargs -r kill -KILL 2>/dev/null || true
        log "Killed processes using root pool $POOL_NAME"
        processes_killed=true
    else
        log "No processes using root pool $POOL_NAME found"
    fi
    
    # Kill processes using any other active ZFS pools
    log "Killing processes using other active ZFS pools..."
    local all_pools=$(zpool list -H -o name 2>/dev/null || true)
    if [[ -n "$all_pools" ]]; then
        while IFS= read -r pool; do
            if [[ "$pool" != "$POOL_NAME" ]]; then
                log "Checking pool: $pool"
                local pool_pids=$(grep "$pool" /proc/*/mounts 2>/dev/null | cut -d/ -f3 | grep '^[0-9]\+$' | sort -u || true)
                if [[ -n "$pool_pids" ]]; then
                    echo "$pool_pids" | xargs -r kill -TERM 2>/dev/null || true
                    sleep 2
                    echo "$pool_pids" | xargs -r kill -KILL 2>/dev/null || true
                    log "Killed processes using pool $pool"
                    processes_killed=true
                fi
            fi
        done <<< "$all_pools"
    fi
    
    log "Process cleanup complete, syncing filesystems..."
    sync
    
    log "Ready for unmounting"
    
    # Return status indicating if processes were killed
    if [[ "$processes_killed" == "true" ]]; then
        return 0  # Processes were killed
    else
        return 1  # No processes were killed
    fi
}

cleanup_mounts() {
    log "Unmounting filesystems..."
    
    # Set umount flags based on DEBUG mode
    local umount_flags="-l -R"
    if [[ "${DEBUG:-false}" == "true" ]]; then
        umount_flags="-l -R -v"
    fi
    
    # Unmount all non-ZFS mounts under $INSTALL_ROOT in reverse order
    mount | grep -v zfs | awk '$3 ~ "^'$INSTALL_ROOT'" {print $3}' | sort | tac | \
        xargs -i{} umount $umount_flags {}
    
    # Unmount any remaining ZFS datasets with mountpoint=legacy
    log "Unmounting any remaining ZFS datasets with mountpoint=legacy..."
    zfs list -H -o name,mountpoint | awk '$2 == "legacy" {print $1}' | \
        xargs -r -i{} sh -c 'mount | grep "^{} " | awk "{print \$3}"' | sort | tac | \
        xargs -r -i{} umount $umount_flags {}
    
    # Clear cache file before exporting pools
    log "Clearing ZFS cache file for pool $POOL_NAME..."
    zpool set cachefile= $POOL_NAME
    
    # Setup ZFS cache files for the installed system
    log "Setting up ZFS cache files for installed system..."
    cp /etc/zfs/zpool.cache "$INSTALL_ROOT/etc/zfs/"
    mkdir -p "/etc/zfs/zfs-list.cache" "$INSTALL_ROOT/etc/zfs/zfs-list.cache"
    truncate -s 0 /etc/zfs/zfs-list.cache/$POOL_NAME
    env -i \
        ZEVENT_POOL=$POOL_NAME \
        ZED_ZEDLET_DIR=/etc/zfs/zed.d \
        ZEVENT_SUBCLASS=history_event \
        ZFS=zfs \
        ZEVENT_HISTORY_INTERNAL_NAME=create \
        /etc/zfs/zed.d/history_event-zfs-list-cacher.sh
    sed -E "s|\t$INSTALL_ROOT/?|\t/|g" "/etc/zfs/zfs-list.cache/$POOL_NAME" > "$INSTALL_ROOT/etc/zfs/zfs-list.cache/$POOL_NAME"
    rm -f "/etc/zfs/zfs-list.cache/$POOL_NAME"
    
    log "Exporting ZFS pools..."
    if zpool export -a; then
        log "ZFS pools exported successfully"
        return 0  # Export succeeded
    else
        warn "ZFS pool export failed"
        return 1  # Export failed
    fi
}

verify_installation() {
    log "Stage 3: Installation cleanup complete!"
    warn "Please remove the installation media and reboot."
    warn "Your new Ubuntu 22.04 with ZFS root should boot automatically."
    echo
    log "After reboot, you can:"
    echo "  - Create ZFS snapshots: sudo zfs snapshot rpool/ROOT/ubuntu@$(date +%Y%m%d)"
    echo "  - List snapshots: zfs list -t snapshot"
    echo "  - Monitor ZFS status: zpool status"
    echo "  - Check ZFS health: zpool scrub rpool"
}

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -D|--debug)
                DEBUG="true"
                shift
                ;;
            *)
                echo "Unknown parameter: $1"
                echo "Usage: $0 [-D|--debug]"
                echo "  -D, --debug    Enable debug mode"
                exit 1
                ;;
        esac
    done
    
    # Enable debug tracing if DEBUG is true (from config or command line)
    if [[ "${DEBUG:-false}" == "true" ]]; then
        set -x
    fi
    
    validate_stage3_config
    
    # Run cleanup_mounts and check if zpool export failed
    if cleanup_mounts; then
        log "Initial cleanup completed successfully, pools exported"
    else
        warn "Initial cleanup failed, running aggressive cleanup..."
        
        # Run aggressive cleanup only if initial cleanup failed
        if aggressive_cleanup; then
            log "Processes were killed during aggressive cleanup, re-exporting ZFS pools..."
            zpool export -a || true
        else
            log "No processes were killed during aggressive cleanup"
            # Try export again after aggressive cleanup
            log "Attempting ZFS pool export again..."
            zpool export -a || true
        fi
    fi
    
    verify_installation
}

main "$@"