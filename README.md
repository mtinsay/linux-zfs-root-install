# ZFS Root Installation Scripts

[![Validate Scripts](https://github.com/username/ubuntu-zfs-root/actions/workflows/validate.yml/badge.svg)](https://github.com/username/ubuntu-zfs-root/actions/workflows/validate.yml)
[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)
[![Ubuntu](https://img.shields.io/badge/Ubuntu-22.04%20|%2024.04-orange.svg)](https://ubuntu.com/)
[![ZFS](https://img.shields.io/badge/ZFS-2.1+-blue.svg)](https://openzfs.org/)

Automated installation scripts for Ubuntu with ZFS root filesystem, based on OpenZFS documentation. Features automatic installation with optional manual control and comprehensive disk safety measures.

**Version 0.1** - Initial release

**Copyright ¬© 2025 Michael C. Tinsay**  
Licensed under the GNU General Public License v3.0

> **üöÄ Built through AI-Human Collaboration**: This entire project was developed through natural language programming, demonstrating the power of collaborative intelligence in creating sophisticated infrastructure automation.

## üì¢ Important Notice

**This is a learning experiment and version 0.1 release.** Thank you for checking out this project! I'm releasing this project as open source to provide you with the opportunity to explore, learn from, and modify it as you see fit, all within the boundaries set by the license. Whether you want to adapt it for your own use, experiment with it, or build upon it, you‚Äôre free to do so. My hope is that this can be a valuable resource for your own projects, a starting point for your own learning, or simply something you can freely tweak and improve. Just be sure to respect the terms of the license as you go‚Äîbeyond that, feel free to shape it however you like!

**‚ö†Ô∏è No Long-term Maintenance**: I wanted to clarify that this is primarily a personal learning experiment, and as such, I don't have plans to maintain or actively develop it long-term. While I'm happy to share my work, please understand that I may not be able to respond to issues, support requests, or pull requests. Given that this project is more about experimentation on my end, I'm not committed to providing ongoing support or making updates. I hope this doesn't deter you from using it or contributing, but please proceed with the understanding that I might not be able to engage with it in a consistent way. I appreciate your understanding and encourage you to explore or contribute as you see fit!

**Use at your own risk and discretion.** The code is provided as-is for educational and experimental purposes.

## ü§ñ AI-Generated Content Disclaimer

**‚ö†Ô∏è IMPORTANT: This entire project is AI-generated content.**

- **Code**: All shell scripts, configuration files, and automation logic were generated by AI without direct human editing
- **Documentation**: All markdown files, specifications, and design documents were created by AI
- **Testing**: No comprehensive human testing or code review has been performed
- **Validation**: While the code follows best practices, human verification of functionality and security is strongly recommended

**Before using in any environment:**
- Thoroughly review all code for your specific use case
- Test extensively in isolated/virtual environments first
- Have qualified personnel validate the implementation
- Understand that AI-generated code may contain subtle bugs or security issues not apparent in automated testing

This project demonstrates AI-human collaborative development but should be treated as experimental code requiring human validation before production use.

## üêß Supported Distributions

This project provides ZFS root installation scripts for multiple Linux distributions:

- **ÔøΩ Uubuntu**: Complete automation for Ubuntu 22.04/24.04 with debootstrap
- **‚ùÑÔ∏è NixOS**: Declarative configuration with NixOS package management

## ‚ú® Features

- **üîß Automated Installation**: Complete unattended ZFS root installation
- **‚öôÔ∏è Flexible Configuration**: Extensive customization via configuration file
- **üíæ Dual Partitioning Modes**: Support for both automatic and manual partitioning
- **üóÑÔ∏è ZFS Pool Management**: Creation, reuse, and forced recreation with comprehensive cleanup
- **üîê SSH Control**: Independent SSH installation control with parameter overrides (Ubuntu)
- **üêõ Debug Framework**: Targeted debug breaks for troubleshooting
- **üßπ Intelligent Cleanup**: Conditional aggressive cleanup based on actual failures
- **üì¶ Multi-Distribution**: Separate script sets for Ubuntu and NixOS
- **üìÅ Enhanced Chroot**: Flexible bind mounting with recursive submount discovery
- **‚úÖ Smart Validation**: Configuration validation with flexible swap configuration
- **üîÑ RAID Support**: mdadm RAID 1 boot partition support with bootloader redundancy
- **üåê Network Customization**: Custom netplan YAML configuration support (Ubuntu)
- **üíø Swap Flexibility**: Optional swap with SWAP_SIZE=0 support
- **üîÑ Cross-Stage Integration**: Proper parameter and error handling across all stages

## üìã Table of Contents

- [Quick Start](#-quick-start)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Usage Examples](#usage-examples)
- [Documentation](#-documentation)
- [Contributing](#-contributing)
- [License](#-license)

## üöÄ Quick Start

### Ubuntu Installation

```bash
# 1. Download the scripts
git clone https://github.com/mtinsay/linux-zfs-root-install.git
cd linux-zfs-root-install

# 2. Configure your installation
nano ubuntu-config.sh  # Edit configuration

# 3. Run the installation
sudo ./ubuntu-stage1.sh -y
```

### NixOS Installation

```bash
# 1. Download the scripts
git clone https://github.com/mtinsay/linux-zfs-root-install.git
cd linux-zfs-root-install

# 2. Configure your installation
nano nixos-config.sh  # Edit configuration

# 3. Run the installation
sudo ./nixos-stage1.sh -y
```

## ‚ö†Ô∏è WARNING
These scripts will **DESTROY ALL DATA** on the target disk. Use only on systems where you can afford to lose all data.

## üîß Command Line Options

### Ubuntu Installation Options

```bash
sudo ./ubuntu-stage1.sh [OPTIONS]

Options:
  -y, --yes              Skip confirmation prompts in auto mode
  -D, --debug            Enable debug mode (pause before chroot)
  -h, --hostname NAME    Override hostname from config
  -d, --disk DEVICE      Override disk device from config
  --auto                 Use automatic partitioning (overrides config)
  --manual               Use manual partitioning (overrides config, default)
  --ssh                  Force SSH installation (overrides config)
  --nossh                Skip SSH installation (overrides config)
  --yaml FILENAME        Use custom netplan YAML file instead of default
  --use-nm               Use NetworkManager renderer (conflicts with --yaml)

Examples:
  sudo ./ubuntu-stage1.sh --auto -y --disk /dev/nvme0n1
  sudo ./ubuntu-stage1.sh --manual --yaml ./custom-network.yaml
  sudo ./ubuntu-stage1.sh --hostname myserver --nossh
  sudo ./ubuntu-stage1.sh --use-nm --auto -y
```

### NixOS Installation Options

```bash
sudo ./nixos-stage1.sh [OPTIONS]

Options:
  -y, --yes              Skip confirmation prompts in auto mode
  -D, --debug            Enable debug mode
  --auto                 Use automatic partitioning (overrides config)
  --manual               Use manual partitioning (overrides config, default)
  -h, --help             Show help message

Examples:
  sudo ./nixos-stage1.sh --auto -y
  sudo ./nixos-stage1.sh --manual --debug
```

## Prerequisites

### Ubuntu Installation
- Ubuntu 22.04/24.04 Live USB/CD
- Target system booted from live media
- Internet connection
- At least 8GB RAM recommended
- UEFI system (Legacy BIOS not supported)

### NixOS Installation
- NixOS Live USB/CD (24.05 or later)
- Target system booted from live media
- Internet connection
- At least 8GB RAM recommended
- UEFI system (Legacy BIOS not supported)

### Manual Partitioning Requirements
If using `PARTITION_MODE="manual"`, ensure your partitions meet these requirements:

- **EFI Partition**: At least 512MB, type EF00 (can be existing/shared)
- **Boot Partition**: Unformatted, at least 1GB, type 8300 (ext4)
- **Root Partition**: Unformatted, remaining space, type BF00 (ZFS will format)
- **Swap Partition** (optional): Can be any size, type 8200

**IMPORTANT**: EFI and Boot partitions MUST be on the same drive for proper GRUB installation.

**EFI Partition Handling**:
- **Existing EFI**: If partition contains EFI files, it will be preserved (dual-boot friendly)
- **Empty EFI**: If formatted but empty, it will be reformatted
- **Unformatted**: Will be formatted as FAT32

Example partitioning with `gdisk`:
```bash
# Create partitions (adjust sizes as needed)
sudo gdisk /dev/sda
# n, 1, default, +512M, EF00    (EFI - can reuse existing)
# n, 2, default, +1G, 8300      (Boot partition - ext4)
# n, 3, default, +2G, 8200      (Swap - optional)
# n, 4, default, default, BF00  (Root pool)
# w (write and exit)
```

### ZFS Dataset Structure

The installation creates a hierarchical dataset structure:

```
rpool/                          # Pool root
‚îî‚îÄ‚îÄ ROOT/                       # Root dataset (configurable, mounted as /)
    ‚îú‚îÄ‚îÄ home/                   # User data
    ‚îÇ   ‚îú‚îÄ‚îÄ root                # Root user home
    ‚îÇ   ‚îî‚îÄ‚îÄ username            # Regular user home
    ‚îú‚îÄ‚îÄ var/                    # Variable data
    ‚îÇ   ‚îú‚îÄ‚îÄ log                 # System logs
    ‚îÇ   ‚îú‚îÄ‚îÄ cache               # Cache data
    ‚îÇ   ‚îî‚îÄ‚îÄ ...                 # Other var datasets
    ‚îú‚îÄ‚îÄ usr/                    # User programs
    ‚îú‚îÄ‚îÄ opt/                    # Optional software
    ‚îú‚îÄ‚îÄ srv/                    # Service data
    ‚îî‚îÄ‚îÄ swap                    # ZFS swap (if configured)
```

**Customizable Root Dataset**:
- `ROOT_DATASET_NAME`: Root dataset name (default: "ROOT")
- All other datasets are created under this root dataset

**Examples**:
```bash
ROOT_DATASET_NAME="SYSTEM"      # Creates rpool/SYSTEM/ (mounted as /)
ROOT_DATASET_NAME="OS"          # Creates rpool/OS/ (mounted as /)
ROOT_DATASET_NAME="ubuntu"      # Creates rpool/ubuntu/ (mounted as /)
```

### ZFS Mount Methods

**fstab Method (Recommended)**:
- Creates `/etc/fstab` entries for each ZFS dataset
- Uses systemd's native mounting capabilities
- Better integration with system services
- Easier troubleshooting and manual mounting

**ZFS Native Method**:
- Uses `zfs mount -a` command via systemd service
- Relies on ZFS's built-in mounting logic
- May be faster for large numbers of datasets
- Uses ZFS mount order dependencies

### ZFS Dataset Configuration Format

Dataset configuration uses the format: `"name:mountpoint:options"`

- **name**: Dataset name relative to pool (e.g., "var/log")
- **mountpoint**: Mount point (used for fstab entry, not ZFS mountpoint property)
- **options**: ZFS properties (optional, comma-separated)

**Important**: 
- All datasets automatically use `mountpoint=legacy` and are mounted via `/etc/fstab`
- Any `mountpoint=` options in the configuration are ignored since `mountpoint=legacy` is forced

Examples:
```bash
"home:/home:"                              # Home directory
"var/log:/var/log:"                       # System logs  
"data:/data:compression=lz4"               # Custom dataset with compression
"backup:/backup:quota=100G"                # Dataset with quota
```

### ZFS Pool Reuse Use Cases
The pool reuse feature is useful for:

- **System reinstallation**: Keep your data while reinstalling the OS
- **Dual-boot setups**: Share ZFS pools between different Ubuntu installations
- **Recovery scenarios**: Reinstall system on existing ZFS infrastructure
- **Upgrade scenarios**: Fresh install while preserving user data
- **New installations**: If `REUSE_ROOT_POOL="true"` but pool doesn't exist, creates new pool automatically

### Network and APT Configuration
The installation preserves your live system configuration:

**Network Configuration**:
- **Default**: Copies all files from `/etc/netplan/` to the installed system
- **Custom YAML**: Use `--yaml FILENAME` to specify a custom netplan configuration
- **NetworkManager**: Use `--use-nm` to create minimal NetworkManager configuration
- Preserves your current network setup (WiFi, static IPs, etc.)
- No need to reconfigure networking after installation

**NetworkManager Option**:
The `--use-nm` parameter creates a minimal netplan configuration that uses NetworkManager as the renderer:
```yaml
network:
  version: 2
  renderer: NetworkManager
```
This is useful for desktop installations where you want NetworkManager to handle all network configuration through its GUI tools.

**APT Sources**:
- Comments out default `sources.list` entries from debootstrap
- Copies all files from `/etc/apt/sources.list.d/` to installed system
- Preserves PPAs, custom repositories, and authentication keys
- Maintains your current package source configuration

### Dual-Boot Support
The installation scripts are designed to work with existing systems:

- **EFI Partition**: Automatically detects and preserves existing EFI files
- **Shared EFI**: Can safely share EFI partition with Windows or other Linux distributions
- **Boot Chain**: GRUB will be installed alongside existing bootloaders
- **ZFS Pools**: Can coexist with other filesystems on the same disk

### Pool Import Behavior
The script automatically handles pool importing:

- **Automatic detection**: Finds pools whether imported or not
- **Safe import**: Uses `-N` flag to prevent automatic mounting during detection
- **Force import**: Uses `-f` flag when importing for reuse (handles dirty pools)
- **Interactive fallback**: Prompts user if unimported pool found during new installation

**Important Notes:**
- Pool names in config must match existing pool names exactly
- Existing datasets are preserved; only missing datasets are created
- Use `EXISTING_ROOT_DATASET` to specify a particular dataset as the new root
- Script handles both imported and unimported existing pools
- Always backup important data before running the installation

## Configuration

Before running, edit the configuration variables in `ubuntu-config.sh`. The script supports two partitioning modes:

### Auto Partitioning Mode (Default)
The script will automatically partition the specified disk:

```bash
PARTITION_MODE="auto"
DISK="/dev/sda"        # WARNING: All data will be destroyed!
EFI_SIZE="512M"
BOOT_SIZE="1G"
```

**Important**: In auto mode, all existing ZFS pools on the target disk are destroyed. `REUSE_ROOT_POOL` and `EXISTING_ROOT_DATASET` settings are ignored.

### Manual Partitioning Mode
Use existing partitions (useful for dual-boot or custom layouts):

```bash
PARTITION_MODE="manual"
EFI_PARTITION="/dev/sda1"    # Existing EFI System Partition
BOOT_PARTITION="/dev/sda2"   # Boot partition (ext4)
ROOT_PARTITION="/dev/sda3"   # Partition for ZFS root pool
SWAP_PARTITION="/dev/sda4"   # Optional: existing swap partition
```

### ZFS Pool Reuse (Manual Mode Only)
Reuse existing ZFS root pool instead of creating new one:

```bash
# ZFS pool reuse options (only works in manual mode)
REUSE_ROOT_POOL="true"      # Reuse existing root pool
EXISTING_ROOT_DATASET=""    # Optional: specific dataset to use as root
                           # e.g., "rpool/ROOT" or "rpool/SYSTEM"
```

**Note**: Pool reuse only works in `PARTITION_MODE="manual"`. Auto mode destroys all existing pools on the target disk.

### ZFS Dataset Configuration
All datasets are configured in a single array:

```bash
# ZFS Dataset Configuration
# Format: "dataset_name:mountpoint:options"
ZFS_DATASETS=(
    # Home datasets
    "home:/home:"
    "home/root:/root:"
    
    # Var datasets
    "var:/var:"
    "var/lib:/var/lib:"
    "var/log:/var/log:"
    "var/cache:/var/cache:"
    
    # Add custom datasets as needed
    "data:/data:compression=lz4,quota=100G"
    # "backup:/backup:quota=50G"
)
```

**Important**: 
- All datasets automatically use `mountpoint=legacy` and are mounted via `/etc/fstab` at boot time
- Any `mountpoint=` options in the configuration are ignored since `mountpoint=legacy` is forced

### Package Configuration
Customize which additional packages are installed:

```bash
# Additional packages to install during stage2
ADDITIONAL_PACKAGES=(
    "ubuntu-minimal"
    "ubuntu-standard"
    "ubuntu-server"
    "cinnamon-desktop-environment"
    "hollywood"
    "sanoid"
)
```

**Customization**:
- Add or remove packages as needed
- Use empty array `ADDITIONAL_PACKAGES=()` to skip additional packages
- Include metapackages like `ubuntu-desktop-minimal` for GUI systems

### Ubuntu Release Configuration
Choose the Ubuntu release to install:

```bash
DEBOOTSTRAP_SUITE="noble"       # Ubuntu 24.04 LTS (default)
# DEBOOTSTRAP_SUITE="jammy"     # Ubuntu 22.04 LTS
# DEBOOTSTRAP_SUITE="focal"     # Ubuntu 20.04 LTS
# DEBOOTSTRAP_SUITE="mantic"    # Ubuntu 23.10
```

**Supported releases**: Any Ubuntu release supported by debootstrap
**LTS releases**: Recommended for production use (focal, jammy, noble)

### Installation Root Configuration
Customize where the system is installed during setup:

```bash
INSTALL_ROOT="/mnt"             # Standard installation root
# INSTALL_ROOT="/target"        # Alternative installation root
```

### Installation Mode Configuration
Choose between automatic and manual installation:

```bash
AUTO_RUN_STAGE2="true"          # Automatic: Stage1 runs Stage2 automatically
# AUTO_RUN_STAGE2="false"       # Manual: Run each stage separately
```

**Automatic Mode** (Recommended):
- Single command installation
- Stage1 automatically executes Stage2 and Stage3
- Complete hands-off installation
- Faster and less error-prone
- Best for most users

**Manual Mode** (Advanced):
- Step-by-step control
- Ability to inspect and modify between stages
- Useful for debugging or customization
- Requires more user interaction

### ZFS Mount Configuration
Choose how ZFS datasets are mounted at boot:

```bash
# Mount method: "fstab" or "zfs"
ZFS_MOUNT_METHOD="fstab"    # Use /etc/fstab entries (recommended)
# ZFS_MOUNT_METHOD="zfs"    # Use ZFS native mounting
```

**fstab method**: Creates entries in `/etc/fstab` for each dataset, mounted by systemd
**zfs method**: Uses `zfs mount -a` command via systemd service

### Common Configuration
```bash
# System configuration
HOSTNAME="ubuntu-zfs"
USERNAME="user"

# Installation configuration
DEBOOTSTRAP_SUITE="noble"       # Ubuntu release (noble=24.04, jammy=22.04, etc.)
INSTALL_ROOT="/mnt"             # Root mountpoint for installation
AUTO_RUN_STAGE2="true"          # Automatically run stage2 after stage1

# ZFS configuration
POOL_NAME="rpool"               # Must match existing pool name if reusing
ROOT_DATASET_NAME="ROOT"        # Root dataset name - all datasets created under this

# Network and locale
NETWORK_INTERFACE="enp0s3"
TIMEZONE="UTC"
LOCALE="en_US.UTF-8"

# Swap (only used if SWAP_PARTITION is empty)
SWAP_SIZE="4G"  # Set to 0 to disable swap entirely

# Color customization (optional)
RED='\033[0;31m'     # Error messages
GREEN='\033[0;32m'   # Info messages  
YELLOW='\033[1;33m'  # Warning messages
```

## Installation Steps

### Automatic Installation (Recommended)
Boot your system from Ubuntu live USB/CD and run:
```bash
# Make scripts executable
chmod +x ubuntu-*.sh

# Edit configuration (IMPORTANT!)
nano ubuntu-config.sh

# Run complete installation (all stages automatically)
sudo ./ubuntu-stage1.sh

# Remove installation media and reboot when prompted
sudo reboot
```

### Manual Installation (Advanced)
For step-by-step control, disable automatic execution:
```bash
# In ubuntu-config.sh, set:
AUTO_RUN_STAGE2="false"

# Run Stage 1: Disk preparation and base system installation
sudo ./ubuntu-stage1.sh

# Manually run Stage 2: System configuration
sudo chroot /mnt /usr/bin/env bash -l
./ubuntu-stage2.sh
exit

# Run Stage 3: Cleanup and prepare for reboot
sudo ./ubuntu-stage3.sh
sudo reboot
```

## What Each Stage Does

### Stage 1: ubuntu-stage1.sh (Main Script)
- **Disk Safety**: Unmounts all partitions and disables swap before disk operations
- Installs ZFS packages
- Partitions the target disk (EFI + Boot + Root + optional Swap)
- Creates ZFS root pool with `devices=on` property for proper root filesystem operation
- Formats boot partition as ext4 with "boot" label, EFI partition as FAT32 with "EFI" label
- Creates ZFS datasets with optimized settings
- Installs base Ubuntu system via debootstrap
- **Enhanced fstab**: Uses `/dev/disk/by-uuid/` references for boot and EFI partitions
- **Secure chroot setup**: Copies apt cache, creates reliable DNS configuration, no EFI variable access
- **In automatic mode**: Executes Stage 2 and Stage 3 automatically

### Stage 2: ubuntu-stage2.sh (System Configuration)
- Configures locale and timezone (sets hardware clock to local time)
- **Non-interactive package configuration**: Uses `dpkg-reconfigure -f noninteractive` for keyboard and console setup
- Installs complete GRUB EFI package set: `grub-efi-amd64`, `grub-efi-amd64-signed`, `shim-signed`
- Installs and configures GRUB bootloader (preserves existing GRUB settings)
- Sets up ZFS services
- Creates user accounts with configurable groups
- Installs configurable additional packages

### Stage 3: ubuntu-stage3.sh (Cleanup)
- **Enhanced mount cleanup**: Uses comprehensive approach to unmount all non-ZFS mounts under `/mnt`
- Exports ZFS pools
- Prepares system for reboot

## Post-Installation

After successful boot into your new ZFS system:

### Create Snapshots
```bash
# Create a snapshot
sudo zfs snapshot rpool/ROOT/ubuntu@$(date +%Y%m%d)

# List snapshots
zfs list -t snapshot
```

### Monitor ZFS Health
```bash
# Check pool status
zpool status

# Run scrub (data integrity check)
sudo zpool scrub rpool

# Check scrub progress
zpool status rpool
```

### ZFS Features
- **Compression**: Enabled (zstd for root filesystem)
- **Snapshots**: Easy system state capture
- **Auto-trim**: Enabled for SSD optimization
- **Datasets**: Organized structure for different mount points
- **Boot**: Traditional ext4 for maximum compatibility
- **Legacy Mounting**: All datasets automatically use `mountpoint=legacy` and mount via `/etc/fstab` at boot

## Troubleshooting

### Boot Issues
- Check GRUB configuration: `/etc/default/grub`
- Verify ZFS bootfs: `zpool get bootfs rpool`
- Update GRUB: `sudo update-grub`

### ZFS Issues
- Import pools manually: `sudo zpool import -f rpool`
- Check ZFS services: `systemctl status zfs.target`
- List available pools: `sudo zpool import`

### Recovery
Boot from live media and import pools:
```bash
sudo zpool import -f rpool
sudo mount -t zfs rpool/ROOT /mnt  # Use your INSTALL_ROOT value
sudo chroot /mnt /bin/bash
```

### ZFS Pool Import Issues
- **Pool not found**: Check `sudo zpool import` to see available pools
- **Pool busy**: Another system may be using the pool, use `-f` to force import
- **Dirty pool**: Pool wasn't cleanly exported, script uses `-f` automatically
- **Permission denied**: Ensure running as root and devices are accessible
- **Dataset conflicts**: Use `EXISTING_ROOT_DATASET` to specify exact dataset
- **Import failures**: 
  ```bash
  # Manual import with force
  sudo zpool import -f -R /mnt <pool_name>
  
  # Check pool status
  sudo zpool status <pool_name>
  
  # Clear errors if needed
  sudo zpool clear <pool_name>
  ```

### EFI Partition Issues
- **EFI not detected**: Check partition type with `sudo gdisk -l /dev/sdX`
- **Mount failures**: Verify partition is not corrupted with `sudo fsck.fat /dev/sdX1`
- **Dual-boot problems**: Ensure EFI partition is large enough (512MB minimum)
- **Manual EFI setup**:
  ```bash
  # Check EFI partition contents
  sudo mkdir -p /tmp/efi && sudo mount /dev/sdX1 /tmp/efi
  sudo ls -la /tmp/efi/EFI/
  sudo umount /tmp/efi
  
  # Force reformat if needed (WARNING: destroys existing bootloaders)
  sudo mkfs.fat -F32 -n EFI /dev/sdX1
  ```

## Customization

### Dataset Customization
You can easily customize the ZFS dataset layout by editing the `ZFS_DATASETS` array in `config.sh`:

- **Change root dataset name**: Modify `ROOT_DATASET_NAME`
- **Add custom datasets**: Add new entries to the `ZFS_DATASETS` array
- **Remove unwanted datasets**: Comment out or delete array entries
- **Change mount points**: Modify the mountpoint field (second field)
- **Add ZFS properties**: Use the options field (third field) for compression, quotas, etc.

Example custom configurations:
```bash
# Custom root dataset name
ROOT_DATASET_NAME="SYSTEM"      # Creates rpool/SYSTEM/ as root filesystem

# Minimal installation
ADDITIONAL_PACKAGES=(
    "ubuntu-minimal"
)

# Server environment
ADDITIONAL_PACKAGES=(
    "ubuntu-minimal"
    "ubuntu-standard"
    "ubuntu-server"
)

# Desktop environment (default)
ADDITIONAL_PACKAGES=(
    "ubuntu-minimal"
    "ubuntu-standard"
    "ubuntu-server"
    "cinnamon-desktop-environment"
    "hollywood"
    "sanoid"
)

# Development environment
ADDITIONAL_PACKAGES=(
    "ubuntu-minimal"
    "ubuntu-standard"
    "ubuntu-server"
    "build-essential"
    "git"
    "python3-pip"
    "nodejs"
    "docker.io"
    "code"
)
```

### Other Customizations
You can also modify the scripts to:
- Adjust compression algorithms
- Add additional packages
- Configure different partitioning schemes
- Set up RAID configurations

## References

Based on the official OpenZFS documentation for Ubuntu 22.04 Root on ZFS installation.#
# Recent Enhancements

### Enhanced Error Handling and Debugging

All Ubuntu stage scripts now include comprehensive error handling and debugging capabilities:

**Enhanced Bash Options**:
```bash
set -Euo pipefail
```
- **`-E`**: ERR trap inheritance by functions and subshells
- **`-u`**: Treat unset variables as errors
- **`-o pipefail`**: Pipeline fails if any command fails

**Debug Tracing**:
- **Automatic activation**: Enable with `DEBUG="true"` in `ubuntu-config.sh`
- **Command line override**: Use `-D` or `--debug` parameter
- **Command visibility**: Shows every executed command when enabled
- **Proper timing**: Debug tracing starts after config and parameter processing

**Debug Usage Examples**:
```bash
# Enable debug via config file
# In ubuntu-config.sh: DEBUG="true"
sudo ./ubuntu-stage1.sh

# Enable debug via command line
sudo ./ubuntu-stage1.sh -D

# Combined with other options
sudo ./ubuntu-stage1.sh -y -D  # Auto-confirm + debug
```

### Enhanced Security and Reliability

**Symlink-Safe resolv.conf Handling**:
- Detects both regular files and symlinks
- Backs up existing configuration before replacement
- Creates reliable DNS configuration for chroot environment

**Improved Command Execution**:
- Uses `eval` for complex command strings to handle paths with spaces
- Proper quoting and argument handling throughout scripts
- Enhanced error reporting with line numbers and failed commands

**Comprehensive Mount Cleanup**:
- Automatically detects and unmounts all non-ZFS mounts under `/mnt`
- Uses reverse order unmounting for proper dependency handling
- Lazy force unmount for stubborn filesystems

### Enhanced fstab Management

**UUID Reference Format**:
```bash
# Boot partition
/dev/disk/by-uuid/12345678-1234-1234-1234-123456789012 /boot ext4 defaults 0 2

# EFI partition
/dev/disk/by-uuid/ABCD-EFGH /boot/efi vfat umask=0077 0 1
```

**Benefits**:
- More explicit than `UUID=` shorthand
- Better debugging and verification capabilities
- Universal compatibility with Linux tools

### ZFS Root Dataset Optimization

**Device Access Configuration**:
```bash
zfs create -o mountpoint=/ -o canmount=on -o devices=on $POOL_NAME/$ROOT_DATASET_NAME
```

**Essential for Root Filesystem**:
- Enables device file access (`/dev/null`, `/dev/zero`, etc.)
- Prevents boot-time device access issues
- Required for proper system operation

### Advanced Disk Safety

**Comprehensive Partition Management**:
- Automatically unmounts all partitions before disk operations
- Disables swap partitions on target disk
- Uses lazy unmount for busy filesystems
- Prevents "device is busy" errors during installation

**Enhanced Package Management**:
- Non-interactive configuration with `dpkg-reconfigure -f noninteractive`
- Complete GRUB EFI package installation for Secure Boot support
- Eliminated duplicate package configuration calls#
## Optimized Partition and Swap Handling

**Reorganized Disk Setup Process**:
The installation process now follows a logical sequence for optimal reliability:

1. **Create partitions** - All partitions (EFI, boot, swap, root) created first
2. **Format partitions** - All formatting happens immediately after creation
3. **Generate fstab entries** - Uses correct UUIDs generated during formatting

**Enhanced Swap Management**:
- **Stage 1 handling**: Swap partition formatted during disk setup phase
- **Immediate UUID generation**: Swap UUID available for fstab creation
- **Consistent formatting**: Uses `mkswap -f` in auto mode, `mkswap` in manual mode
- **Proper fstab entries**: Uses `/dev/disk/by-uuid/` format for consistency

**Benefits**:
- **Correct UUID availability**: fstab entries always have valid UUIDs
- **Logical organization**: All disk operations happen together
- **Improved reliability**: No timing issues with UUID generation
- **Consistent format**: All partition entries use same UUID reference style### 
Latest System Integration Improvements

**Enhanced ZFS Dataset Management**:
- **Native ZFS mounting**: Uses `zfs mount` instead of manual mount commands for root datasets
- **Proper ZFS integration**: Leverages ZFS's built-in mounting capabilities with `canmount=on`
- **Consistent behavior**: All root dataset scenarios use the same ZFS-native approach

**Improved GRUB Configuration**:
- **Escaped ZFS paths**: Properly escapes forward slashes in `root=ZFS=` parameter
- **Reliable sed operations**: Prevents delimiter conflicts in GRUB configuration
- **Robust boot parameters**: Ensures correct ZFS root specification regardless of dataset names

**Enhanced System Configuration**:
- **Symlink-safe os-release handling**: Properly copies `/etc/os-release` whether it's a file or symlink
- **Content preservation**: Follows symlinks to copy actual file content
- **Modern system compatibility**: Works with distributions that use symlinked os-release files

**Optimized Execution Flow**:
- **Logical ZFS ordering**: ZFS pools and datasets created immediately after partitioning
- **Early chroot setup**: Chroot environment established right after dataset creation
- **Improved dependency management**: Each operation builds properly on previous steps### En
hanced Command Line Interface

**Extended Parameter Support**:
The installation script now supports additional command line parameters for greater flexibility:

```bash
# Basic usage
sudo ./ubuntu-stage1.sh

# Skip confirmation prompts
sudo ./ubuntu-stage1.sh -y

# Enable debug mode
sudo ./ubuntu-stage1.sh -D

# Override hostname from command line
sudo ./ubuntu-stage1.sh -h myserver

# Override disk device from command line
sudo ./ubuntu-stage1.sh -d /dev/nvme0n1

# Combined parameters
sudo ./ubuntu-stage1.sh -y -D -h webserver -d /dev/sdb
```

**Command Line Parameters**:
- **`-y, --yes`**: Skip confirmation prompts in auto mode
- **`-D, --debug`**: Enable debug mode with command tracing
- **`-h, --hostname HOSTNAME`**: Override hostname from config file
- **`-d, --disk DEVICE`**: Override disk device from config file

**Parameter Benefits**:
- **Configuration override**: Command line parameters take precedence over config file
- **Deployment flexibility**: Easy customization without editing config files
- **Automation friendly**: Scriptable installations with different parameters
- **Testing support**: Quick testing with different hostnames and disks

**Optimized User Creation**:
- **Improved timing**: User accounts created after additional packages are installed
- **Package availability**: Ensures all required packages are available for user setup
- **Dependency resolution**: User creation happens when system is fully configured##
# Advanced ZFS Pool Management and System Identity

**Enhanced Manual Mode Pool Reuse**:
- **Intelligent mounting**: Automatically mounts existing root datasets when reusing pools
- **Pool import handling**: Properly mounts datasets after pool import operations
- **Existing dataset support**: Handles both specified existing datasets and default root datasets
- **Mount state management**: Ensures root datasets are mounted regardless of previous state

**Improved System Identity Management**:
- **Host system preservation**: Copies host system's `/etc/os-release` for consistent identity
- **Temporary staging**: Uses `/tmp` directory for temporary file storage during installation
- **GRUB integration**: Updates system identity before GRUB configuration generation
- **Symlink-safe operations**: Handles both regular files and symlinks for `/etc/os-release`

**ZFS Dataset Optimization**:
- **Automatic mounting**: Relies on ZFS's built-in mounting with `canmount=on`
- **Eliminates redundancy**: Removes unnecessary manual mount commands
- **Native ZFS behavior**: Leverages ZFS properties for proper dataset management
- **Manual mode exceptions**: Uses explicit mounting only when required for existing datasets

**Benefits**:
- **Reliable pool reuse**: Existing pools are properly mounted and accessible
- **System consistency**: Installed system maintains host system identity
- **Reduced complexity**: Eliminates unnecessary mount operations
- **Modern compatibility**: Handles current Linux distribution file structures#
## Final Production Enhancements

**Enhanced Debug Support**:
- **Stage 2 debug pause**: Added debug pause before exiting chroot environment
- **Complete debug flow**: Debug support now spans all three installation stages
- **User control**: Allows inspection and manual intervention at critical points

**Optimized Configuration**:
- **Larger partitions**: Increased EFI partition to 1GB and boot partition to 4GB for better compatibility
- **Updated user account**: Changed default user to `localadmin` with preset password
- **Future-proofing**: Accommodates larger kernels and more boot files

**Enhanced GRUB Management**:
- **Optimized timing**: GRUB installation and configuration moved to final system preparation
- **Complete system state**: Bootloader setup happens when system is fully configured
- **Better integration**: GRUB sees all installed packages and created users

**Advanced Stage 3 Cleanup**:
- **Intelligent unmounting**: Sophisticated mount detection and unmounting with proper ordering
- **ZFS-aware cleanup**: Separate handling for ZFS datasets with legacy mountpoints
- **Pre-cleanup validation**: Comprehensive checks for open files, locks, and potential issues
- **Error detection**: Strict error handling with verbose output in debug mode
- **User guidance**: Clear problem reporting with actionable resolution steps

**Robust Error Handling**:
- **Strict unmounting**: Removed lazy unmount flags to detect and report issues
- **Comprehensive validation**: Pre-cleanup checks prevent common failure scenarios
- **Debug visibility**: Conditional verbose output based on DEBUG setting
- **User interaction**: Pause and guidance when potential issues are detected### 
ZFS Cache File Management and Advanced Cleanup

**Comprehensive ZFS Cache File Handling**:
- **Pool creation**: Automatically sets cache file for all new pools
- **Pool reuse**: Configures cache file for existing pools being reused
- **Clean export**: Clears cache file before pool export in Stage 3
- **System integration**: Ensures proper ZFS service integration and automatic pool import

**Advanced Pre-Cleanup Validation**:
- **Open file detection**: Checks for files in use under installation root
- **Process monitoring**: Identifies processes with working directories in installation area
- **Swap conflict detection**: Warns about active swap that might interfere
- **ZFS pool health**: Validates pool status before cleanup operations
- **User guidance**: Provides actionable steps for resolving detected issues

**Intelligent Cleanup Operations**:
- **Ordered unmounting**: Consistent sorting and reversal for proper dependency handling
- **ZFS-aware cleanup**: Separate handling for legacy mountpoint datasets
- **Strict error detection**: Removed lazy unmount to catch and report issues
- **Debug-aware verbosity**: Conditional verbose output based on DEBUG setting
- **Comprehensive coverage**: Handles all filesystem types with appropriate methods

**Enhanced Error Handling**:
- **Proactive validation**: Identifies potential issues before they cause failures
- **User interaction**: Allows informed decisions about proceeding with cleanup
- **Clear reporting**: Detailed information about detected problems
- **Recovery guidance**: Specific steps for resolving common issues
## Z
FS Cache File Management and Advanced Cleanup

### ZFS Cache File Management

The installation system implements comprehensive ZFS cache file management to ensure proper system integration:

**Universal Cache File Setting**:
- **New pools**: Cache file set immediately after pool creation
- **Reused pools**: Cache file set when importing existing pools
- **All scenarios**: Ensures automatic pool import by ZFS services

```bash
# Applied to all pool creation/import scenarios
zpool set cachefile=/etc/zfs/zpool.cache $POOL_NAME
```

**Clean Export Process**:
- **Cache file clearing**: Removes cache file before pool export
- **Clean handoff**: Ensures proper state for installed system
- **System integration**: Enables ZFS services to manage pools correctly

```bash
# Before exporting pools in stage 3
zpool set cachefile= $POOL_NAME
zpool export -a
```

### Advanced Pre-Cleanup Validation

The system includes comprehensive pre-cleanup validation to prevent common unmount and export failures:

**Multi-Faceted Issue Detection**:
- **Open files**: Detects processes holding files open under installation root
- **Working directories**: Identifies processes with CWD in installation area
- **Active swap**: Warns about swap that might interfere with operations
- **ZFS pool status**: Checks for degraded or faulted pool conditions

**User Guidance and Control**:
- **Issue reporting**: Clear identification of potential problems
- **Actionable advice**: Specific steps to resolve detected issues
- **User decision**: Option to continue despite warnings or abort to fix issues
- **Informed choices**: Detailed information enables proper decision-making

### Intelligent Cleanup Operations

**Sophisticated Unmounting Pipeline**:
```bash
# Consistent pipeline pattern for all unmounting operations
source | filter | extract | sort | tac | execute

# Example: Non-ZFS filesystem unmounting
mount | grep -v zfs | awk '$3 ~ "^'$INSTALL_ROOT'" {print $3}' | sort | tac | \
    xargs -i{} umount $umount_flags {}
```

**Pipeline Benefits**:
- **Consistent ordering**: All unmounting uses same sort-then-reverse pattern
- **Dependency safety**: Deeper mount points unmounted before parent mounts
- **ZFS awareness**: Separate handling for ZFS-managed vs legacy-mounted datasets
- **Debug integration**: Conditional verbose output based on DEBUG setting

### Enhanced Error Handling

**Strict Error Detection**:
- **No lazy unmount**: Removed `-l` flags to detect busy filesystems
- **Visible failures**: Commands fail explicitly instead of continuing silently
- **Error suppression removed**: Eliminated `|| true` constructs for clear failure detection
- **Debug verbosity**: Conditional `-v` flags provide detailed output when debugging

**Error Handling Benefits**:
- **Immediate feedback**: Problems detected and reported immediately
- **Clear diagnostics**: Specific error messages with context
- **Recovery guidance**: Actionable steps for resolving issues
- **Debug support**: Verbose output available when troubleshooting## Final Pro
duction Optimizations

### Aggressive Process Management

The installation system now includes aggressive process cleanup to eliminate all potential unmount interference:

**Comprehensive Process Elimination**:
- **Open file cleanup**: Automatically kills processes with open files under installation root
- **Working directory cleanup**: Kills processes with working directory in installation area
- **ZFS process cleanup**: Targets processes using ZFS mounts via /proc/*/mounts analysis
- **Graceful then forceful**: Uses TERM signal first, then KILL after 2-second delay

**Universal Swap Management**:
- **Complete swap disable**: Runs `swapoff -a` to disable all active swap
- **Error tolerance**: Continues operation even if swap disable fails
- **Unmount preparation**: Eliminates swap-related "device busy" errors

### Optimized Package Management

**Enhanced Package Copying**:
- **rsync instead of cp**: More efficient copying with `rsync -a` for apt cache
- **Better performance**: Incremental copying and attribute preservation
- **Reliable transfers**: Superior handling of interrupted operations

**Streamlined Package Selection**:
- **Ubuntu Desktop**: Standard Ubuntu desktop experience instead of Cinnamon
- **Essential SSH**: Included for remote access capability
- **Minimal datasets**: Only home datasets created by default, others optional

### Advanced ZFS Cache Management

**Comprehensive ZFS List Cache Setup**:
- **Pool cache copying**: Transfers zpool.cache to installed system
- **List cache generation**: Creates ZFS list cache using history event cacher
- **Path translation**: Converts installation paths to runtime paths
- **Clean handoff**: Provides complete ZFS cache infrastructure to installed system

**ZFS Cache Benefits**:
- **Faster boot times**: Pre-generated cache eliminates dataset discovery delays
- **Service integration**: Enables ZFS event daemon and caching services
- **Proper mounting**: Ensures datasets mount correctly after reboot

### Enhanced Error Handling

**Graceful Pool Export**:
- **Error tolerance**: `zpool export -a || true` ignores export errors
- **Installation completion**: Ensures script succeeds despite minor issues
- **Reboot safety**: System can reboot successfully even with export problems

**Optimized Cleanup Sequence**:
1. **Process elimination**: Kill all interfering processes
2. **Swap disable**: Turn off all swap
3. **Filesystem sync**: Flush all pending writes
4. **Unmount operations**: Clean filesystem unmounting
5. **Pool export**: Export ZFS pools with error tolerance

### System Optimization

**Package Cache Cleanup**:
- **apt clean**: Removes package cache before exiting chroot
- **Reduced disk usage**: Cleaner final installation
- **Storage optimization**: No unnecessary cached packages

**Filesystem Synchronization**:
- **sync command**: Ensures all writes flushed before unmounting
- **Data integrity**: Prevents data loss during unmount operations
- **Optimal timing**: Sync after process cleanup, before unmounting## U
ltimate Cleanup Architecture and Pool Management

### Two-Stage Cleanup Orchestration

The installation system now implements sophisticated two-stage cleanup for maximum reliability:

**Orchestrated Cleanup Sequence**:
1. **Initial cleanup**: `cleanup_mounts()` performs standard unmounting and pool export
2. **Aggressive cleanup**: `aggressive_cleanup()` eliminates any remaining interfering processes
3. **Conditional re-export**: Re-exports pools only if additional processes were killed
4. **Status tracking**: Clear indication of whether post-cleanup actions were needed

**Process Tracking and Conditional Actions**:
- **Process elimination tracking**: Monitors whether any processes were actually killed
- **Return status**: Function returns success/failure based on cleanup activity
- **Conditional re-export**: Only re-exports ZFS pools when additional cleanup occurred
- **Efficient operation**: Avoids unnecessary operations when no cleanup was needed

### Enhanced Process Safety

**Numeric PID Filtering**:
- **Safety validation**: `grep '^[0-9]\+$'` ensures only numeric PIDs are processed
- **Error prevention**: Prevents "invalid signal specification" errors from malformed PIDs
- **Robust operation**: Handles edge cases where lsof or /proc parsing returns unexpected output
- **Applied universally**: All PID extraction operations include numeric filtering

**Lazy Unmount Implementation**:
- **Guaranteed success**: `-l` flag ensures unmounts never fail due to "device busy" errors
- **Immediate detachment**: Filesystems removed from namespace immediately
- **Background cleanup**: Actual unmounting occurs when references are released
- **Debug integration**: Verbose output (`-v`) available when debugging enabled

### Advanced Debug Integration

**Step-by-Step Debug Pauses**:
- **Process cleanup steps**: Pause after each type of process elimination
- **Swap operations**: Pause after swap disable operations
- **ZFS pool cleanup**: Pause after each pool's process cleanup
- **User control**: Complete control over cleanup execution timing
- **System inspection**: Opportunity to run diagnostic commands between steps

**Debug Capabilities**:
- **Detailed troubleshooting**: Step-by-step inspection of all cleanup operations
- **Process verification**: Verify process elimination before proceeding to next step
- **Issue isolation**: Identify which cleanup step encounters problems
- **Abort capability**: User can abort at any pause point if issues detected

### Pool State Management

**Clean Pool Initialization**:
- **Export/re-import cycle**: Ensures newly created pools start in cleanest state
- **Cache refresh**: Forces ZFS to refresh all cached pool information
- **Metadata consistency**: Guarantees proper synchronization of pool metadata
- **Import validation**: Verifies pool can be successfully imported
- **Device detection**: Forces re-detection of pool devices and properties

**Pool State Benefits**:
- **Clean initialization**: Pool starts in optimal state for dataset creation
- **Altroot establishment**: Cleanly establishes altroot setting for installation
- **Consistency guarantee**: Ensures all pool operations work with fresh state
- **Validation assurance**: Confirms pool is properly accessible before proceeding

### Function Architecture Improvements

**Semantic Function Naming**:
- **`aggressive_cleanup()`**: Renamed from `check_unmount_readiness()` for clarity
- **Clear intent**: Function name immediately indicates aggressive action taken
- **Accurate description**: Reflects actual behavior rather than passive checking
- **Developer clarity**: Makes code intent obvious to maintainers and users

### System Reliability Enhancements

**Zero-Failure Cleanup**:
- **Guaranteed completion**: Cleanup process always completes successfully
- **Error tolerance**: Non-critical operations use `|| true` for graceful handling
- **Lazy unmounts**: Eliminate most common source of unmount failures
- **Process elimination**: Aggressive cleanup removes all potential interference

**Intelligent Operation**:
- **Conditional actions**: Operations performed only when actually needed
- **Status tracking**: Clear indication of system state and actions taken
- **Efficient execution**: Avoids unnecessary operations when system is already clean
- **Comprehensive coverage**: Handles all potential sources of installation interference## 
Advanced System Configuration and SSH Management

### Flexible SSH Installation Control

The installation system provides comprehensive control over SSH server installation:

**Configuration-Based Control**:
- **Default setting**: `INSTALL_SSH="true"` in ubuntu-config.sh
- **Security option**: Set to `"false"` to create systems without SSH
- **Override capability**: Command-line parameters override configuration

**Command-Line SSH Control**:
```bash
# Force SSH installation (overrides config)
sudo ./ubuntu-stage1.sh --ssh

# Skip SSH installation (overrides config)  
sudo ./ubuntu-stage1.sh --nossh

# Use configuration setting (default behavior)
sudo ./ubuntu-stage1.sh
```

**Parameter Validation**:
- **Conflict detection**: Cannot use `--ssh` and `--nossh` together
- **Cross-stage consistency**: Same validation in both stage 1 and stage 2
- **Clear error messages**: Immediate feedback on parameter conflicts
- **Parameter propagation**: SSH settings flow from stage 1 to stage 2

### Advanced System Optimization

**Comprehensive System Upgrade**:
- **Distribution upgrade**: `apt dist-upgrade -y` ensures latest packages
- **Package minimization**: `apt-mark minimize-manual` cleans package state
- **Timing**: Performed before SSH and service installation
- **Security**: Applies available security updates during installation

**Optimized Package Management**:
- **Merged installations**: Single apt commands for related packages
- **Kernel packages**: `linux-generic linux-generic-hwe${hwe_suffix} zfs-initramfs`
- **Configuration**: `keyboard-configuration console-setup` reconfigured together
- **Efficiency**: Reduced command overhead and faster execution

### Parameter Architecture

**Cross-Stage Parameter Flow**:
- **Stage 1 parsing**: Validates and tracks SSH parameters
- **Parameter propagation**: SSH settings passed to stage 2
- **Debug continuity**: Debug mode maintained throughout installation
- **Override consistency**: Command-line overrides work across all stages

**Parameter Validation Features**:
- **Conflict detection**: Prevents contradictory SSH installation directives
- **Early validation**: Parameter conflicts detected before system modification
- **User guidance**: Clear usage information and error messages
- **Robust handling**: Graceful error handling for invalid parameter combinations

### Configuration Management

**Enhanced Configuration Validation**:
- **SSH configuration**: `INSTALL_SSH` added to required variables
- **Complete validation**: All configuration items validated before installation
- **Early failure**: Missing configuration detected before system changes
- **Clear reporting**: Specific identification of missing configuration items

**Configuration Benefits**:
- **Flexibility**: Control SSH installation via configuration or command-line
- **Security**: Option to create systems without SSH for high-security environments
- **Consistency**: Uniform configuration handling across all installation stages
- **Reliability**: Comprehensive validation prevents partial installations

### Code Optimization

**Performance Improvements**:
- **Line merging**: Related operations combined for efficiency
- **Reduced overhead**: Fewer command invocations for faster execution
- **Atomic operations**: Related packages installed together
- **Consistent patterns**: Similar operations use uniform formatting

**Maintenance Benefits**:
- **Reduced complexity**: Fewer lines to maintain and debug
- **Improved readability**: Related operations grouped logically
- **Consistent structure**: Uniform code patterns throughout system
- **Efficient debugging**: Clearer code structure for troubleshooting#
# Final System Optimizations and Framework Evolution

### Streamlined Debug Framework

The installation system has evolved from interactive debug pauses to a targeted debug break system:

**Debug Framework Evolution**:
- **Removed interactive pauses**: No more debug_pause calls interrupting installation flow
- **Targeted debug breaks**: debug_break functions available for manual insertion when needed
- **Automated execution**: Installation runs completely unattended by default
- **Cross-stage handling**: Enhanced error handling for debug breaks across all stages

**Debug Break Capability**:
- **Manual debugging**: debug_break functions remain available for troubleshooting
- **Exit code 99**: Special debug exit code for proper cross-stage detection
- **Controlled termination**: Intentional stopping points when debugging specific issues

### Intelligent Cleanup Architecture

**Conditional Aggressive Cleanup**:
- **Failure-driven approach**: Aggressive cleanup only runs if zpool export fails
- **Performance optimization**: Most installations complete without process killing
- **Smart escalation**: Escalates cleanup measures only when necessary
- **Efficient execution**: Avoids unnecessary operations when system is clean

**Enhanced Unmount Operations**:
- **Recursive unmounting**: `-R` flag ensures complete cleanup of nested mounts
- **Lazy unmounting**: `-l` flag prevents "device busy" errors
- **Bind mount cleanup**: Properly handles complex mount hierarchies
- **Debug visibility**: Verbose output available when debugging enabled

### Advanced Package Management

**Minimal Default Configuration**:
- **Empty package arrays**: All additional packages commented out by default
- **User flexibility**: Easy to uncomment desired packages
- **SSH separation**: SSH controlled independently via INSTALL_SSH configuration
- **Validation intelligence**: Distinguishes between missing variables and empty arrays

**System Optimization**:
- **Distribution upgrade**: `apt dist-upgrade -y` ensures latest packages
- **Package minimization**: `apt-mark minimize-manual -y` cleans package state
- **Non-interactive operations**: All package operations use -y flag for automation
- **Timing optimization**: System upgrades performed before service installation

### Flexible Bind Mount System

**Advanced Chroot Environment Setup**:
```bash
bind_mount() {
    local source_dir="$1"
    local target_dir="$2" 
    local recursive="${3:-false}"
    
    # Basic bind mount with privacy
    mount -v --bind "$source_dir" "$target_dir"
    mount -v --make-private "$target_dir"
    
    # Optional recursive submount handling
    if [[ "$recursive" == "true" ]]; then
        # Discover and mount all subdirectories
    fi
}
```

**Chroot Setup Implementation**:
```bash
# Recursively bind mount necessary filesystems
bind_mount "/dev" "$INSTALL_ROOT/dev" true
bind_mount "/proc" "$INSTALL_ROOT/proc" true
bind_mount "/sys" "$INSTALL_ROOT/sys" true
```

**Bind Mount Benefits**:
- **Explicit control**: Individual mount management instead of recursive flags
- **Flexible recursion**: Optional recursive behavior per mount point
- **Discovery-based**: Automatically finds and mounts all subdirectories
- **Namespace isolation**: Each mount gets individual privacy settings
- **Granular management**: Can handle each submount with specific options

### Configuration Architecture Improvements

**Logical Organization**:
- **Contextual guidance**: Important requirements placed where most relevant
- **Immediate visibility**: Users see constraints when configuring related items
- **Reduced errors**: Critical information positioned at point of configuration
- **Clean structure**: Proper file formatting with appropriate spacing

**Enhanced Validation**:
- **Smart array checking**: Allows empty arrays while catching missing variables
- **Flexible package configuration**: Supports minimal installations with no additional packages
- **Clear error reporting**: Specific identification of actual configuration issues
- **User-friendly validation**: Distinguishes between intentional and accidental empty configurations#
# üìö Documentation

- **[README.md](README.md)** - Main documentation and usage guide
- **[DESIGN.md](DESIGN.md)** - Architecture and design documentation
- **[SPECS.md](SPECS.md)** - Technical specifications and requirements
- **[CONTRIBUTING.md](CONTRIBUTING.md)** - Contribution guidelines
- **[CHANGELOG.md](CHANGELOG.md)** - Version history and changes
- **[SECURITY.md](SECURITY.md)** - Security policy and considerations
- **[blog-post.md](blog-post.md)** - Development journey and methodology

## ü§ù Contributing

**Note**: This is a learning experiment (version 0.1) with no long-term maintenance plans. The author will not be responsive to issues, support requests, or pull requests.

However, since this is open source, you're free to:
- Fork the project and maintain your own version
- Learn from the code and implementation
- Adapt it for your own needs
- Create your own improved version

The code is provided as-is for educational and experimental purposes. If you find it useful, feel free to build upon it!

## üêõ Bug Reports and Support

**Important**: The author will not be responsive to bug reports, feature requests, or support questions. This is a learning experiment with no maintenance commitment.

However, the issue templates are provided for community use:
- **Bug Reports**: [Bug Report Template](.github/ISSUE_TEMPLATE/bug_report.md)
- **Feature Requests**: [Feature Request Template](.github/ISSUE_TEMPLATE/feature_request.md)
- **Support Questions**: [Support Template](.github/ISSUE_TEMPLATE/support_question.md)

Community members may help each other, but don't expect responses from the original author.

## üìä Project Stats

- **Language**: Bash
- **Lines of Code**: ~2000+
- **Documentation**: 15,000+ words
- **Development Method**: AI-Human Collaboration
- **Test Coverage**: Virtual machine validated

## üèÜ Acknowledgments

This project showcases the transformative potential of AI-human collaboration in software development. The entire codebase was developed through natural language programming, demonstrating that complex, production-ready infrastructure automation can be built through conversational development.

Special recognition to the collaborative development process that made this project possible, proving that AI-human partnerships can exceed traditional development approaches in both quality and development velocity.

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ‚≠ê Star History

If you find this project useful, please consider giving it a star! It helps others discover the project and shows appreciation for the collaborative development approach.

---

**Built with ‚ù§Ô∏è through AI-Human Collaboration**