#!/bin/bash

# ZFS Root Installation Scripts - NixOS Stage 1 (v0.1)
# Copyright (C) 2025 Michael C. Tinsay
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Based on OpenZFS NixOS documentation
# WARNING: This script will destroy data on the target disk!
#
# ⚠️  AI-GENERATED CODE DISCLAIMER ⚠️
# This script was entirely generated by AI without direct human editing.
# No comprehensive human testing or code review has been performed.
# Thoroughly test in isolated environments and have qualified personnel
# review before using in any production or important system.
# Use at your own risk - AI-generated code may contain subtle bugs.

# Enhanced bash options for better error handling
set -Euo pipefail

# Error handling with line number reporting
error_exit() {
    local exit_code=$?
    if [[ $exit_code -eq 99 ]]; then
        echo -e "${YELLOW}DEBUG BREAK: Debug break triggered in stage 2${NC}" >&2
        echo -e "${YELLOW}Installation stopped for debugging purposes${NC}" >&2
        exit 99
    else
        echo -e "${RED}ERROR: Script failed at line $1${NC}" >&2
        echo -e "${RED}Command: $2${NC}" >&2
        exit 1
    fi
}

# Set up error trap
trap 'error_exit ${LINENO} "$BASH_COMMAND"' ERR

# Load configuration
if [[ ! -f "nixos-config.sh" ]]; then
    echo -e "${RED}ERROR: nixos-config.sh not found!${NC}" >&2
    echo "Please ensure nixos-config.sh is in the same directory as this script." >&2
    exit 1
fi

source nixos-config.sh

# Logging functions
log() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}" >&2
}

error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}" >&2
}

# Validation functions
validate_config() {
    log "Validating configuration..."
    
    if [[ "$PARTITION_MODE" == "auto" ]]; then
        if [[ -z "$DISK" ]]; then
            error "DISK must be specified for auto partitioning mode"
            exit 1
        fi
        
        if [[ ! -b "$DISK" ]]; then
            error "Disk $DISK does not exist or is not a block device"
            exit 1
        fi
        
        log "Auto partitioning mode: Will use disk $DISK"
        warn "ALL DATA ON $DISK WILL BE DESTROYED!"
        
    elif [[ "$PARTITION_MODE" == "manual" ]]; then
        if [[ -z "$EFI_PARTITION" || -z "$BOOT_PARTITION" || -z "$ROOT_PARTITION" ]]; then
            error "EFI_PARTITION, BOOT_PARTITION, and ROOT_PARTITION must be specified for manual mode"
            exit 1
        fi
        
        for partition in "$EFI_PARTITION" "$BOOT_PARTITION" "$ROOT_PARTITION"; do
            if [[ ! -b "$partition" ]]; then
                error "Partition $partition does not exist or is not a block device"
                exit 1
            fi
        done
        
        if [[ -n "$SWAP_PARTITION" && ! -b "$SWAP_PARTITION" ]]; then
            error "Swap partition $SWAP_PARTITION does not exist or is not a block device"
            exit 1
        fi
        
        # Validate EFI and Boot partition compatibility
        validate_boot_efi_compatibility
        
        log "Manual partitioning mode: Using existing partitions"
    else
        error "PARTITION_MODE must be either 'auto' or 'manual'"
        exit 1
    fi
    
    # Validate ZFS pool name
    if [[ ! "$POOL_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
        error "Invalid pool name: $POOL_NAME"
        error "Pool name must start with a letter and contain only letters, numbers, underscores, and hyphens"
        exit 1
    fi
    
    # Validate hostname
    if [[ ! "$HOSTNAME" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
        error "Invalid hostname: $HOSTNAME"
        exit 1
    fi
    
    log "Configuration validation passed"
}

validate_boot_efi_compatibility() {
    log "Validating EFI and Boot partition compatibility..."
    
    local efi_drive=$(echo "$EFI_PARTITION" | sed 's/[0-9]*$//')
    
    # Check if boot partition is an mdadm RAID device
    if [[ "$BOOT_PARTITION" =~ ^/dev/md[0-9]+$ ]]; then
        log "Boot partition is mdadm RAID device: $BOOT_PARTITION"
        
        # Verify RAID device exists and is active
        if [[ ! -b "$BOOT_PARTITION" ]]; then
            error "RAID device $BOOT_PARTITION does not exist"
        fi
        
        if ! mdadm --detail "$BOOT_PARTITION" >/dev/null 2>&1; then
            error "RAID device $BOOT_PARTITION is not active or accessible"
        fi
        
        # Get RAID level and validate it's RAID 1
        local raid_level
        raid_level=$(mdadm --detail "$BOOT_PARTITION" | grep "Raid Level" | awk '{print $4}')
        
        if [[ "$raid_level" != "raid1" ]]; then
            error "Boot partition RAID device must be RAID 1 (mirror), found: $raid_level"
            error "GRUB requires RAID 1 for boot partition support"
        fi
        
        log "Verified RAID 1 configuration for boot partition"
        
        # Get active devices in the RAID array
        local raid_devices
        raid_devices=$(mdadm --detail "$BOOT_PARTITION" | grep -E "^\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+active sync" | awk '{print $7}')
        
        if [[ -z "$raid_devices" ]]; then
            error "No active devices found in RAID array $BOOT_PARTITION"
        fi
        
        log "Active RAID devices: $raid_devices"
        
        # Check if any RAID device is on the same drive as EFI partition
        local efi_compatible="false"
        for device in $raid_devices; do
            local device_drive=$(echo "$device" | sed 's/[0-9]*$//')
            log "Checking RAID device $device (drive: $device_drive) against EFI drive: $efi_drive"
            
            if [[ "$device_drive" == "$efi_drive" ]]; then
                log "Found RAID device $device on same drive as EFI partition ($efi_drive)"
                efi_compatible="true"
                break
            fi
        done
        
        if [[ "$efi_compatible" != "true" ]]; then
            error "RAID 1 boot partition requires at least one active device on the same drive as EFI partition"
            error "EFI partition: $EFI_PARTITION (drive: $efi_drive)"
            error "RAID devices: $raid_devices"
            error "None of the RAID devices are on drive $efi_drive"
            error "This is required for GRUB installation compatibility"
        fi
        
        log "RAID 1 boot partition validation passed - compatible with EFI partition"
        
    else
        # Standard partition validation
        local boot_drive=$(echo "$BOOT_PARTITION" | sed 's/[0-9]*$//')
        
        if [[ "$efi_drive" != "$boot_drive" ]]; then
            error "EFI partition ($EFI_PARTITION) and Boot partition ($BOOT_PARTITION) must be on the same drive"
            error "EFI drive: $efi_drive, Boot drive: $boot_drive"
            error "This is required for proper GRUB installation"
            error ""
            error "Alternative: Use mdadm RAID 1 for boot partition with one device on the EFI drive"
        fi
        
        log "Standard boot partition validation passed - same drive as EFI partition"
    fi
}

# Partition disk for auto mode
partition_disk() {
    if [[ "$PARTITION_MODE" != "auto" ]]; then
        return 0
    fi
    
    log "Partitioning disk $DISK..."
    
    # Clear existing partition table
    sgdisk --zap-all "$DISK"
    
    # Create partitions
    sgdisk -n 1:0:+$EFI_SIZE -t 1:EF00 -c 1:"EFI System" "$DISK"
    sgdisk -n 2:0:+$BOOT_SIZE -t 2:8300 -c 2:"Boot" "$DISK"
    
    if [[ -n "$SWAP_SIZE" && "$SWAP_SIZE" != "0" ]]; then
        sgdisk -n 3:0:+$SWAP_SIZE -t 3:8200 -c 3:"Swap" "$DISK"
        sgdisk -n 4:0:0 -t 4:8300 -c 4:"ZFS Root" "$DISK"
        SWAP_PARTITION="${DISK}3"
        ROOT_PARTITION="${DISK}4"
    else
        log "SWAP_SIZE is 0 or empty - swap partition disabled"
        sgdisk -n 3:0:0 -t 3:8300 -c 3:"ZFS Root" "$DISK"
        ROOT_PARTITION="${DISK}3"
    fi
    
    EFI_PARTITION="${DISK}1"
    BOOT_PARTITION="${DISK}2"
    
    # Inform kernel of partition changes
    partprobe "$DISK"
    sleep 2
    
    log "Disk partitioning completed"
    log "EFI partition: $EFI_PARTITION"
    log "Boot partition: $BOOT_PARTITION"
    log "Root partition: $ROOT_PARTITION"
    if [[ -n "$SWAP_PARTITION" ]]; then
        log "Swap partition: $SWAP_PARTITION"
    fi
}

# Format partitions
format_partitions() {
    log "Formatting partitions..."
    
    # Format EFI partition
    log "Formatting EFI partition $EFI_PARTITION as FAT32..."
    mkfs.fat -F 32 -n EFI "$EFI_PARTITION"
    
    # Format boot partition
    log "Formatting boot partition $BOOT_PARTITION as ext4..."
    mkfs.ext4 -F -F -L boot "$BOOT_PARTITION"
    
    # Format swap partition if specified
    if [[ -n "$SWAP_PARTITION" ]]; then
        log "Formatting swap partition $SWAP_PARTITION..."
        mkswap -L swap "$SWAP_PARTITION"
    else
        log "No swap partition configured - skipping swap formatting"
    fi
    
    log "Partition formatting completed"
}

# Create ZFS pool and datasets
create_zfs_pool() {
    log "Creating ZFS pool and datasets..."
    
    # Handle existing pool based on REUSE_ROOT_POOL setting
    local pool_exists="false"
    
    # Check if pool exists (imported or not)
    if zpool list "$POOL_NAME" >/dev/null 2>&1; then
        pool_exists="true"
        log "Found existing imported pool: $POOL_NAME"
    elif zpool import -d /dev 2>/dev/null | grep -q "pool: $POOL_NAME"; then
        pool_exists="true"
        log "Found existing unimported pool: $POOL_NAME"
    fi
    
    if [[ "$pool_exists" == "true" ]]; then
        if [[ "$REUSE_ROOT_POOL" == "true" ]]; then
            log "Reusing existing ZFS pool: $POOL_NAME"
            
            # Import pool if not already imported
            if ! zpool list "$POOL_NAME" >/dev/null 2>&1; then
                log "Importing existing pool: $POOL_NAME"
                zpool import -f "$POOL_NAME"
            fi
            
            # Check if existing root dataset should be used
            if [[ -n "$EXISTING_ROOT_DATASET" ]] && zfs list "$EXISTING_ROOT_DATASET" >/dev/null 2>&1; then
                log "Reusing existing root dataset: $EXISTING_ROOT_DATASET"
                ROOT_DATASET="$EXISTING_ROOT_DATASET"
            else
                # Create new root dataset
                ROOT_DATASET="$POOL_NAME/$ROOT_DATASET_NAME"
                if ! zfs list "$ROOT_DATASET" >/dev/null 2>&1; then
                    log "Creating new root dataset: $ROOT_DATASET"
                    zfs create -o mountpoint=none "$ROOT_DATASET"
                else
                    log "Using existing root dataset: $ROOT_DATASET"
                fi
            fi
        else
            # REUSE_ROOT_POOL=false: Destroy existing pool
            log "REUSE_ROOT_POOL=false: Destroying existing pool '$POOL_NAME'"
            
            # Import pool if not already imported (needed for destruction)
            if ! zpool list "$POOL_NAME" >/dev/null 2>&1; then
                log "Importing pool for destruction: $POOL_NAME"
                zpool import -f "$POOL_NAME" 2>/dev/null || true
            fi
            
            # Destroy the pool
            if zpool list "$POOL_NAME" >/dev/null 2>&1; then
                log "Destroying pool: $POOL_NAME"
                zpool destroy -f "$POOL_NAME" || {
                    warn "Failed to destroy pool $POOL_NAME, attempting export..."
                    zpool export -f "$POOL_NAME" 2>/dev/null || true
                }
            fi
            
            # Ignore EXISTING_ROOT_DATASET when not reusing pool
            if [[ -n "$EXISTING_ROOT_DATASET" ]]; then
                log "REUSE_ROOT_POOL=false: Ignoring EXISTING_ROOT_DATASET setting"
            fi
            
            # Create new pool after destruction
            log "Creating new ZFS pool: $POOL_NAME"
            zpool create -f \
                -o ashift=12 \
                -o autotrim=on \
                -O acltype=posixacl \
                -O canmount=off \
                -O compression=zstd \
                -O dnodesize=auto \
                -O normalization=formD \
                -O relatime=on \
                -O xattr=sa \
                -O mountpoint=none \
                "$POOL_NAME" "$ROOT_PARTITION"
            
            # Create root dataset
            ROOT_DATASET="$POOL_NAME/$ROOT_DATASET_NAME"
            log "Creating root dataset: $ROOT_DATASET"
            zfs create -o mountpoint=none "$ROOT_DATASET"
        fi
    else
        # No existing pool - create new one
        log "Creating new ZFS pool: $POOL_NAME"
        zpool create -f \
            -o ashift=12 \
            -o autotrim=on \
            -O acltype=posixacl \
            -O canmount=off \
            -O compression=zstd \
            -O dnodesize=auto \
            -O normalization=formD \
            -O relatime=on \
            -O xattr=sa \
            -O mountpoint=none \
            "$POOL_NAME" "$ROOT_PARTITION"
        
        # Create root dataset
        ROOT_DATASET="$POOL_NAME/$ROOT_DATASET_NAME"
        log "Creating root dataset: $ROOT_DATASET"
        zfs create -o mountpoint=none "$ROOT_DATASET"
    fi
    
    # Create system datasets
    create_zfs_datasets
    
    log "ZFS pool and datasets created successfully"
}

# Create ZFS datasets
create_zfs_datasets() {
    log "Creating ZFS datasets..."
    
    # Create root filesystem dataset
    local root_fs_dataset="$ROOT_DATASET/root"
    if ! zfs list "$root_fs_dataset" >/dev/null 2>&1; then
        log "Creating root filesystem dataset: $root_fs_dataset"
        zfs create -o mountpoint=legacy "$root_fs_dataset"
    else
        log "Root filesystem dataset already exists: $root_fs_dataset"
        zfs set mountpoint=legacy "$root_fs_dataset"
    fi
    
    # Create configured datasets
    for dataset_config in "${ZFS_DATASETS[@]}"; do
        if [[ -z "$dataset_config" ]]; then
            continue
        fi
        
        IFS=':' read -r dataset_name mountpoint options <<< "$dataset_config"
        
        if [[ -z "$dataset_name" || -z "$mountpoint" ]]; then
            warn "Skipping invalid dataset configuration: $dataset_config"
            continue
        fi
        
        local full_dataset_name="$ROOT_DATASET/$dataset_name"
        
        if ! zfs list "$full_dataset_name" >/dev/null 2>&1; then
            log "Creating dataset: $full_dataset_name (mountpoint: $mountpoint)"
            
            # Create dataset with legacy mountpoint
            if [[ -n "$options" ]]; then
                zfs create -o mountpoint=legacy -o "$options" "$full_dataset_name"
            else
                zfs create -o mountpoint=legacy "$full_dataset_name"
            fi
        else
            log "Dataset already exists: $full_dataset_name"
            zfs set mountpoint=legacy "$full_dataset_name"
        fi
    done
    
    log "ZFS datasets created successfully"
}

# Mount filesystems
mount_filesystems() {
    log "Mounting filesystems..."
    
    # Mount root filesystem
    local root_fs_dataset="$ROOT_DATASET/root"
    log "Mounting root filesystem: $root_fs_dataset -> $INSTALL_ROOT"
    mount -t zfs "$root_fs_dataset" "$INSTALL_ROOT"
    
    # Create mount points and mount datasets
    for dataset_config in "${ZFS_DATASETS[@]}"; do
        if [[ -z "$dataset_config" ]]; then
            continue
        fi
        
        IFS=':' read -r dataset_name mountpoint options <<< "$dataset_config"
        
        if [[ -z "$dataset_name" || -z "$mountpoint" ]]; then
            continue
        fi
        
        local full_dataset_name="$ROOT_DATASET/$dataset_name"
        local full_mountpoint="$INSTALL_ROOT$mountpoint"
        
        # Create mount point
        mkdir -p "$full_mountpoint"
        
        # Mount dataset
        log "Mounting dataset: $full_dataset_name -> $full_mountpoint"
        mount -t zfs "$full_dataset_name" "$full_mountpoint"
    done
    
    # Mount boot partition
    mkdir -p "$INSTALL_ROOT/boot"
    log "Mounting boot partition: $BOOT_PARTITION -> $INSTALL_ROOT/boot"
    mount "$BOOT_PARTITION" "$INSTALL_ROOT/boot"
    
    # Mount EFI partition
    mkdir -p "$INSTALL_ROOT/boot/efi"
    log "Mounting EFI partition: $EFI_PARTITION -> $INSTALL_ROOT/boot/efi"
    mount "$EFI_PARTITION" "$INSTALL_ROOT/boot/efi"
    
    # Enable swap if configured
    if [[ -n "$SWAP_PARTITION" ]]; then
        log "Enabling swap: $SWAP_PARTITION"
        swapon "$SWAP_PARTITION"
    fi
    
    log "Filesystem mounting completed"
}

# Generate NixOS configuration
generate_nixos_config() {
    log "Generating NixOS configuration..."
    
    # Generate hardware configuration
    log "Generating hardware configuration..."
    nixos-generate-config --root "$INSTALL_ROOT"
    
    # Create custom configuration.nix
    log "Creating custom configuration.nix..."
    cat > "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
# NixOS ZFS Root Configuration
# Generated by ZFS Root Installation Scripts

{ config, pkgs, ... }:

{
  imports = [
    ./hardware-configuration.nix
  ];

  # Boot loader configuration
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  boot.loader.timeout = $BOOTLOADER_TIMEOUT;

  # ZFS support
  boot.supportedFilesystems = [ "zfs" ];
  boot.zfs.forceImportRoot = false;
  boot.zfs.extraPools = [ "$POOL_NAME" ];
EOF

    # Add RAID support if boot partition is RAID
    if [[ "$BOOT_PARTITION" =~ ^/dev/md[0-9]+$ ]]; then
        cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF

  # RAID support for boot partition
  boot.swraid.enable = true;
  boot.swraid.mdadmConf = '''
    ARRAY $BOOT_PARTITION
  ''';
EOF
    fi

    cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF

  # Network configuration
  networking.hostName = "$HOSTNAME";
  networking.hostId = "$(head -c 8 /etc/machine-id)";
  networking.networkmanager.enable = true;

  # Time zone and locale
  time.timeZone = "$TIMEZONE";
  i18n.defaultLocale = "$LOCALE";

  # System packages
  environment.systemPackages = with pkgs; [
$(printf '    %s\n' "${SYSTEM_PACKAGES[@]}")
  ];

  # Services
$(for service in "${SYSTEM_SERVICES[@]}"; do
    echo "  services.$service.enable = true;"
done)

EOF

    # Add desktop environment if specified
    if [[ -n "$DESKTOP_ENVIRONMENT" ]]; then
        case "$DESKTOP_ENVIRONMENT" in
            "gnome")
                cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
  # GNOME Desktop Environment
  services.xserver.enable = true;
  services.xserver.displayManager.gdm.enable = true;
  services.xserver.desktopManager.gnome.enable = true;

EOF
                ;;
            "kde")
                cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
  # KDE Plasma Desktop Environment
  services.xserver.enable = true;
  services.xserver.displayManager.sddm.enable = true;
  services.xserver.desktopManager.plasma5.enable = true;

EOF
                ;;
            "xfce")
                cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
  # XFCE Desktop Environment
  services.xserver.enable = true;
  services.xserver.displayManager.lightdm.enable = true;
  services.xserver.desktopManager.xfce.enable = true;

EOF
                ;;
        esac
    fi

    # Add user configuration
    cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
  # User configuration
  users.users = {
EOF

    for user_config in "${USERS[@]}"; do
        if [[ -z "$user_config" ]]; then
            continue
        fi
        
        IFS=':' read -r username groups password description <<< "$user_config"
        
        if [[ -z "$username" ]]; then
            continue
        fi
        
        cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
    $username = {
      isNormalUser = true;
      description = "$description";
EOF
        
        if [[ -n "$groups" ]]; then
            echo "      extraGroups = [ \"$(echo "$groups" | sed 's/,/" "/g')\" ];" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
        fi
        
        if [[ -n "$password" ]]; then
            # Hash the password
            local hashed_password
            hashed_password=$(echo "$password" | mkpasswd -m sha-512 -s)
            echo "      hashedPassword = \"$hashed_password\";" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
        fi
        
        echo "    };" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
    done

    cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF
  };

  # Hardware configuration
EOF

    if [[ "$ENABLE_MICROCODE_UPDATES" == "true" ]]; then
        echo "  hardware.cpu.intel.updateMicrocode = true;" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
        echo "  hardware.cpu.amd.updateMicrocode = true;" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
    fi

    if [[ "$ENABLE_FIRMWARE_UPDATES" == "true" ]]; then
        echo "  hardware.enableRedistributableFirmware = true;" >> "$INSTALL_ROOT/etc/nixos/configuration.nix"
    fi

    cat >> "$INSTALL_ROOT/etc/nixos/configuration.nix" << EOF

  # System state version
  system.stateVersion = "24.05";
}
EOF

    log "NixOS configuration generated successfully"
}

# Main installation function
main() {
    local auto_confirm="false"
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -y|--yes)
                auto_confirm="true"
                shift
                ;;
            -D|--debug)
                DEBUG="true"
                shift
                ;;
            -h|--help)
                echo "Usage: $0 [OPTIONS]"
                echo "Options:"
                echo "  -y, --yes     Auto-confirm destructive operations"
                echo "  -D, --debug   Enable debug mode"
                echo "  -h, --help    Show this help message"
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                echo "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
    
    log "Starting NixOS ZFS Root Installation - Stage 1"
    log "Configuration loaded from nixos-config.sh"
    
    # Validate configuration
    validate_config
    
    # Confirm destructive operations
    if [[ "$PARTITION_MODE" == "auto" && "$auto_confirm" != "true" ]]; then
        echo
        warn "DESTRUCTIVE OPERATION WARNING!"
        warn "This will DESTROY ALL DATA on disk: $DISK"
        echo
        read -p "Are you sure you want to continue? (yes/no): " -r
        if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
            log "Installation cancelled by user"
            exit 0
        fi
    fi
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root"
        exit 1
    fi
    
    # Partition disk (if auto mode)
    partition_disk
    
    # Format partitions
    format_partitions
    
    # Create ZFS pool and datasets
    create_zfs_pool
    
    # Mount filesystems
    mount_filesystems
    
    # Generate NixOS configuration
    generate_nixos_config
    
    log "Stage 1 completed successfully!"
    
    # Run stage 2 if configured
    if [[ "$AUTO_RUN_STAGE2" == "true" ]]; then
        log "AUTO_RUN_STAGE2 is enabled, starting stage 2..."
        if [[ -f "nixos-stage2.sh" ]]; then
            exec bash nixos-stage2.sh
        else
            error "nixos-stage2.sh not found!"
            exit 1
        fi
    else
        log "Run nixos-stage2.sh to continue with the installation"
    fi
}

# Run main function with all arguments
main "$@"