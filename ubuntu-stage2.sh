#!/bin/bash

# ZFS Root Installation Scripts - Stage 2: Chroot Configuration (v0.1)
# Copyright (C) 2025 Michael C. Tinsay
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Run this script inside the chroot environment
#
# ⚠️  AI-GENERATED CODE DISCLAIMER ⚠️
# This script was entirely generated by AI without direct human editing.
# No comprehensive human testing or code review has been performed.
# Thoroughly test in isolated environments and have qualified personnel
# review before using in any production or important system.
# Use at your own risk - AI-generated code may contain subtle bugs.

# Enhanced bash options for better error handling
set -Euo pipefail

# Error handling with line number reporting
error_exit() {
    echo -e "${RED}ERROR: Script failed at line $1${NC}" >&2
    echo -e "${RED}Command: $2${NC}" >&2
    exit 1
}
trap 'error_exit ${LINENO} "$BASH_COMMAND"' ERR

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/ubuntu-config.sh"

if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Configuration file $CONFIG_FILE not found!"
    echo "Please ensure ubuntu-config.sh exists in the same directory as this script."
    exit 1
fi

source "$CONFIG_FILE"

# Colors are loaded from ubuntu-config.sh

validate_stage2_config() {
    local missing_vars=()
    
    # Required variables for stage2
    local required_vars=(
        "HOSTNAME"
        "TIMEZONE"
        "LOCALE"
        "NETWORK_INTERFACE"
        "DEBOOTSTRAP_SUITE"
        "INSTALL_SSH"
        "RED"
        "GREEN"
        "YELLOW"
        "NC"
    )
    
    # Check required variables
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var}" ]]; then
            missing_vars+=("$var")
        fi
    done
    
    # Check if ADDITIONAL_PACKAGES array exists (allow empty array)
    if ! declare -p ADDITIONAL_PACKAGES &>/dev/null; then
        missing_vars+=("ADDITIONAL_PACKAGES")
    fi
    
    # Check if USERS array exists
    if [[ -z "${USERS[*]}" ]]; then
        missing_vars+=("USERS")
    fi
    
    # Report missing variables
    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        echo -e "${RED}[ERROR] Missing required configuration variables in ubuntu-config.sh:${NC}"
        for var in "${missing_vars[@]}"; do
            echo -e "${RED}[ERROR]   - $var${NC}"
        done
        echo -e "${RED}[ERROR]${NC}"
        echo -e "${RED}[ERROR] Please check your ubuntu-config.sh file and ensure all required variables are defined.${NC}"
        exit 1
    fi
}

log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

debug_break() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        warn "DEBUG BREAK: $1"
        warn "Exiting with error status for debugging..."
        exit 99  # Special debug exit code
    fi
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

configure_locale() {
    log "Configuring locale..."
    locale-gen $LOCALE
    echo "LANG=\"$LOCALE\"" > /etc/default/locale
    dpkg-reconfigure -f noninteractive locales
}

configure_timezone() {
    # Set hardware clock to local time first (useful for dual-boot with Windows)
    log "Setting hardware clock to local time..."
    # Create /etc/adjtime to configure hardware clock as local time
    cat > /etc/adjtime << 'EOF'
0.0 0 0.0
0
LOCAL
EOF
    
    log "Configuring timezone..."
    ln -fs /usr/share/zoneinfo/$TIMEZONE /etc/localtime
    dpkg-reconfigure -f noninteractive tzdata
}

update_system() {
    log "Updating package lists..."
    apt update || true
}

install_kernel() {
    log "Installing kernel and ZFS..."
    
    # Determine HWE suffix based on Ubuntu release
    local hwe_suffix=""
    case "$DEBOOTSTRAP_SUITE" in
        "focal")   hwe_suffix="-20.04" ;;
        "jammy")   hwe_suffix="-22.04" ;;
        "noble")   hwe_suffix="-24.04" ;;
        "mantic")  hwe_suffix="-23.10" ;;
        *)         hwe_suffix="-24.04" ;;  # Default fallback (Ubuntu 24.04)
    esac
    
    # Install both generic and HWE kernels with all recommended packages
    apt install -y linux-generic linux-generic-hwe${hwe_suffix} zfs-initramfs
    
    # Reconfigure packages non-interactively (packages are already installed)
    dpkg-reconfigure -f noninteractive keyboard-configuration console-setup
}

install_grub() {
    log "Installing and configuring GRUB..."
    

    
    apt install -y grub-efi-amd64 grub-efi-amd64-signed shim-signed
    
    # Configure GRUB using sed to preserve existing settings
    log "Configuring GRUB settings..."
    
    # Get swap partition UUID for hibernation resume
    local swap_uuid=""
    if [[ -n "$SWAP_PARTITION" ]]; then
        swap_uuid=$(blkid -s UUID -o value "$SWAP_PARTITION" 2>/dev/null || echo "")
    fi
    
    # Configure GRUB_CMDLINE_LINUX with ZFS root and performance parameters
    # First, ensure GRUB_CMDLINE_LINUX exists
    if ! grep -q "^GRUB_CMDLINE_LINUX=" /etc/default/grub; then
        echo 'GRUB_CMDLINE_LINUX=""' >> /etc/default/grub
    fi
    
    # Add ZFS root parameter if not already present
    if ! grep -q "root=ZFS=" /etc/default/grub; then
        sed -i '/^GRUB_CMDLINE_LINUX=/ s/"$/ root=ZFS='$POOL_NAME'\/'$ROOT_DATASET_NAME'"/' /etc/default/grub
    fi
    
    # Add performance parameters if not already present
    if ! grep -q "init_on_alloc=0" /etc/default/grub; then
        sed -i '/^GRUB_CMDLINE_LINUX=/ s/"$/ init_on_alloc=0"/' /etc/default/grub
    fi
    if ! grep -q "mitigations=off" /etc/default/grub; then
        sed -i '/^GRUB_CMDLINE_LINUX=/ s/"$/ mitigations=off"/' /etc/default/grub
    fi
    
    # Clean up leading/trailing spaces and multiple spaces in GRUB_CMDLINE_LINUX
    sed -i '/^GRUB_CMDLINE_LINUX=/ s/="[[:space:]]*/="/' /etc/default/grub
    sed -i '/^GRUB_CMDLINE_LINUX=/ s/[[:space:]]*"$/"/' /etc/default/grub
    sed -i '/^GRUB_CMDLINE_LINUX=/ s/[[:space:]]\+/ /g' /etc/default/grub
    
    # Configure GRUB_CMDLINE_LINUX_DEFAULT with performance and hibernation settings
    # First, ensure GRUB_CMDLINE_LINUX_DEFAULT exists
    if ! grep -q "^GRUB_CMDLINE_LINUX_DEFAULT=" /etc/default/grub; then
        echo 'GRUB_CMDLINE_LINUX_DEFAULT=""' >> /etc/default/grub
    fi
    
    # Remove "quiet" and "splash" from existing GRUB_CMDLINE_LINUX_DEFAULT
    sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/\bquiet\b//g' /etc/default/grub
    sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/\bsplash\b//g' /etc/default/grub
    
    # Performance parameters are now in GRUB_CMDLINE_LINUX (moved above)
    
    # Add hibernation resume parameter if swap partition exists
    if [[ -n "$swap_uuid" ]] && ! grep -q "resume=UUID=" /etc/default/grub; then
        sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/"$/ resume=UUID='$swap_uuid'"/' /etc/default/grub
    fi
    
    # Clean up leading/trailing spaces and multiple spaces in GRUB_CMDLINE_LINUX_DEFAULT
    sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/="[[:space:]]*/="/' /etc/default/grub
    sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/[[:space:]]*"$/"/' /etc/default/grub
    sed -i '/^GRUB_CMDLINE_LINUX_DEFAULT=/ s/[[:space:]]\+/ /g' /etc/default/grub
    
    # Comment out GRUB_TIMEOUT_STYLE=hidden if it exists
    sed -i 's/^GRUB_TIMEOUT_STYLE=/#&/' /etc/default/grub
    
    # Set GRUB_TIMEOUT=5
    if grep -q "^GRUB_TIMEOUT=" /etc/default/grub; then
        sed -i '/^GRUB_TIMEOUT=/c\GRUB_TIMEOUT=5' /etc/default/grub
    else
        echo "GRUB_TIMEOUT=5" >> /etc/default/grub
    fi
    
    # Set GRUB_RECORDFAIL_TIMEOUT right after GRUB_TIMEOUT
    if ! grep -q "^GRUB_RECORDFAIL_TIMEOUT=" /etc/default/grub; then
        sed -i '/^GRUB_TIMEOUT=/a GRUB_RECORDFAIL_TIMEOUT=5' /etc/default/grub
    fi
    
    # Configure GRUB_TERMINAL=console
    if grep -q "^#.*GRUB_TERMINAL=console" /etc/default/grub; then
        # Uncomment existing commented GRUB_TERMINAL=console
        sed -i 's/^#.*GRUB_TERMINAL=console/GRUB_TERMINAL=console/' /etc/default/grub
    elif grep -q "^GRUB_TERMINAL=console" /etc/default/grub; then
        # GRUB_TERMINAL=console already exists and is active - do nothing
        log "GRUB_TERMINAL=console already configured"
    elif grep -q "^GRUB_TERMINAL=" /etc/default/grub; then
        # Different GRUB_TERMINAL exists - comment it out and add console after it
        sed -i 's/^GRUB_TERMINAL=/#&/' /etc/default/grub
        sed -i '/^#GRUB_TERMINAL=/a GRUB_TERMINAL=console' /etc/default/grub
    else
        # No GRUB_TERMINAL line exists - add it
        echo "GRUB_TERMINAL=console" >> /etc/default/grub
    fi

    
    update-grub
    

    log "Installing GRUB to EFI directory"
    grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=ubuntu --recheck --no-floppy
    
    # Additional GRUB installation for RAID boot partitions
    install_grub_for_raid
}

install_grub_for_raid() {
    # Check if boot partition is an mdadm RAID device
    if [[ "$BOOT_PARTITION" =~ ^/dev/md[0-9]+$ ]]; then
        log "Configuring GRUB for RAID 1 boot partition: $BOOT_PARTITION"
        
        # Get active devices in the RAID array
        local raid_devices
        raid_devices=$(mdadm --detail "$BOOT_PARTITION" | grep -E "^\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+[0-9]+\s+active sync" | awk '{print $7}')
        
        if [[ -z "$raid_devices" ]]; then
            warn "No active devices found in RAID array $BOOT_PARTITION"
            return
        fi
        
        log "Installing GRUB to RAID member drives for redundancy..."
        
        # Install GRUB to each active RAID member drive
        for device in $raid_devices; do
            local device_drive=$(echo "$device" | sed 's/[0-9]*$//')
            log "Installing GRUB to drive: $device_drive (member: $device)"
            
            # Install GRUB to the drive (not the partition)
            if grub-install --target=i386-pc --boot-directory=/boot "$device_drive"; then
                log "Successfully installed GRUB to $device_drive"
            else
                warn "Failed to install GRUB to $device_drive - RAID redundancy may be compromised"
            fi
        done
        
        # Update GRUB configuration to handle RAID
        log "Updating GRUB configuration for RAID support..."
        
        # Ensure mdadm is available in initramfs
        if ! grep -q "^MODULES.*raid1" /etc/initramfs-tools/modules; then
            echo "raid1" >> /etc/initramfs-tools/modules
            log "Added raid1 module to initramfs"
        fi
        
        if ! grep -q "^MODULES.*md_mod" /etc/initramfs-tools/modules; then
            echo "md_mod" >> /etc/initramfs-tools/modules
            log "Added md_mod module to initramfs"
        fi
        
        # Update initramfs to include RAID modules
        log "Updating initramfs with RAID modules..."
        update-initramfs -u
        
        log "GRUB RAID configuration completed"
    else
        log "Boot partition is not RAID - skipping RAID-specific GRUB configuration"
    fi
}

configure_zfs() {
    log "Configuring ZFS..."
    
    # Enable ZFS services
    systemctl enable zfs.target
    systemctl enable zfs-import-cache
    systemctl enable zfs-mount
    systemctl enable zfs-import.target
    
    # Set bootfs property
    zpool set bootfs=$POOL_NAME/$ROOT_DATASET_NAME $POOL_NAME
}


configure_zfs_mounting() {
    log "Configuring ZFS dataset mounting..."
    
    if [[ "$ZFS_MOUNT_METHOD" == "zfs" ]]; then
        log "Enabling ZFS native mounting service..."
        systemctl enable zfs-mount-datasets.service
    elif [[ "$ZFS_MOUNT_METHOD" == "fstab" ]]; then
        log "Using fstab for ZFS dataset mounting..."
        # Create systemd service to mount ZFS datasets from fstab
        cat > /etc/systemd/system/mount-zfs-datasets.service << 'EOF'
[Unit]
Description=Mount ZFS datasets from fstab
After=zfs-import.target
Wants=zfs-import.target
DefaultDependencies=no

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/mount -a -t zfs

[Install]
WantedBy=multi-user.target
EOF
        systemctl enable mount-zfs-datasets.service
    fi
}

create_users() {
    log "Creating user accounts..."
    
    # Collect all groups that will be needed
    local all_groups=()
    for user_config in "${USERS[@]}"; do
        # Skip empty entries and comments
        if [[ -n "$user_config" && ! "$user_config" =~ ^[[:space:]]*# ]]; then
            local username groups password
            IFS=':' read -r username groups password <<< "$user_config"
            
            if [[ -n "$groups" ]]; then
                IFS=',' read -ra user_groups <<< "$groups"
                for group in "${user_groups[@]}"; do
                    # Trim whitespace and add to all_groups if not already present
                    group=$(echo "$group" | xargs)
                    if [[ -n "$group" ]] && [[ ! " ${all_groups[*]} " =~ " $group " ]]; then
                        all_groups+=("$group")
                    fi
                done
            fi
        fi
    done
    
    # Ensure all required groups exist
    for group in "${all_groups[@]}"; do
        if ! getent group "$group" >/dev/null 2>&1; then
            log "Creating group: $group"
            groupadd "$group"
        fi
    done
    
    # Create each user
    for user_config in "${USERS[@]}"; do
        # Skip empty entries and comments
        if [[ -n "$user_config" && ! "$user_config" =~ ^[[:space:]]*# ]]; then
            local username groups password
            IFS=':' read -r username groups password <<< "$user_config"
            
            log "Creating user: $username"
            
            # Create user
            adduser --disabled-password --gecos "" "$username"
            
            # Add user to specified groups
            if [[ -n "$groups" ]]; then
                log "Adding $username to groups: $groups"
                usermod -aG "$groups" "$username"
            fi
            
            # Create user home directory (as regular folder, not ZFS dataset)
            log "Creating home directory for $username"
            mkdir -p "/home/$username"
            chown "$username:$username" "/home/$username"
            
            # Set password
            if [[ -n "$password" ]]; then
                log "Setting preset password for user $username"
                if echo "$username:$password" | chpasswd; then
                    log "Password set successfully for user $username"
                else
                    warn "Failed to set preset password for user $username"
                    warn "Please set password manually after installation: sudo passwd $username"
                fi
            else
                warn "Please set password for user $username:"
                if ! passwd "$username"; then
                    warn "Failed to set password for user $username"
                    warn "Please set password manually after installation: sudo passwd $username"
                fi
            fi
        fi
    done
}

install_openssh() {
    log "Installing SSH metapackage..."
    apt install -y ssh
    
    # Configure SSH
    sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin no/' /etc/ssh/sshd_config
    systemctl enable ssh
}



install_additional_packages() {
    if [[ ${#ADDITIONAL_PACKAGES[@]} -gt 0 ]]; then
        log "Installing additional packages..."
        log "Packages: ${ADDITIONAL_PACKAGES[*]}"
        apt install -y "${ADDITIONAL_PACKAGES[@]}"
    else
        log "No additional packages configured for installation"
    fi
}

cleanup() {
    log "Cleaning up..."
    apt autoremove -y --purge
    apt autoclean
}

final_configuration() {
    log "Final configuration..."
    
    # Update initramfs
    update-initramfs -c -k all
}

main() {
    # Parse command line arguments
    local ssh_param_used="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -D|--debug)
                DEBUG="true"
                shift
                ;;
            --ssh)
                if [[ "$ssh_param_used" == "true" ]]; then
                    echo "Error: --ssh and --nossh cannot be used together"
                    exit 1
                fi
                INSTALL_SSH="true"
                ssh_param_used="true"
                shift
                ;;
            --nossh)
                if [[ "$ssh_param_used" == "true" ]]; then
                    echo "Error: --ssh and --nossh cannot be used together"
                    exit 1
                fi
                INSTALL_SSH="false"
                ssh_param_used="true"
                shift
                ;;
            *)
                echo "Unknown parameter: $1"
                echo "Usage: $0 [-D|--debug] [--ssh|--nossh]"
                echo "  -D, --debug    Enable debug mode"
                echo "  --ssh          Force SSH installation (overrides config)"
                echo "  --nossh        Skip SSH installation (overrides config)"
                exit 1
                ;;
        esac
    done
    
    # Enable debug tracing if DEBUG is true (from config or command line)
    if [[ "${DEBUG:-false}" == "true" ]]; then
        set -x
    fi
    
    log "Starting Stage 2: Chroot configuration..."
    
    validate_stage2_config
    configure_locale
    configure_timezone
    update_system
    install_kernel
    configure_zfs
    configure_zfs_mounting
    
    # Upgrade system and minimize manual packages
    log "Performing distribution upgrade..."
    apt dist-upgrade -y
    log "Minimizing manually installed packages..."
    apt-mark minimize-manual -y
    
    # Install SSH if enabled
    if [[ "$INSTALL_SSH" == "true" ]]; then
        install_openssh
    else
        log "Skipping SSH installation (INSTALL_SSH=false)"
    fi
    
    # Install additional packages if any are configured
    if [[ ${#ADDITIONAL_PACKAGES[@]} -gt 0 ]]; then
        install_additional_packages
    else
        log "No additional packages configured, skipping package installation"
    fi
    
    create_users
    cleanup
    
    # Install and configure GRUB after all system configuration is complete
    install_grub
    
    # Update GRUB configuration after all system configuration is complete
    log "Updating GRUB configuration..."
    update-grub
    
    final_configuration
    
    log "Stage 2 complete!"
    log "Exit chroot (type 'exit') and run Stage 3: ./stage3-cleanup-installation.sh"
    
    # Clean package cache before exiting
    log "Cleaning package cache..."
    apt clean
}

main "$@"